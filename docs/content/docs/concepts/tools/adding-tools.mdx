---
title: Adding Local Tools
description: Add local tools to extend Tambo's capabilities
---

Define your tool function and register it with Tambo. Local tools are JavaScript functions that run in your React app. Use them for DOM interactions, wrapping authenticated fetch requests, or accessing React state.

```tsx
//define the tool function. This is your own custom function and can perform any logic you want.
const getWeather = async (city: string) => {
  try {
    const weather = await fetch(
      `http://api.weatherapi.com/v1/current.json?key=${process.env.NEXT_PUBLIC_WEATHER_API_KEY}&q=${city}`,
    );
    return weather.json();
  } catch (error) {
    throw new Error(`Failed to fetch weather for ${city}`);
  }
};

// Create a TamboTool definition including your tool function
export const tools: TamboTool[] = [
  {
    name: "get_weather",
    description: "Fetch current weather information for a specified city",
    tool: getWeather,
    toolSchema: z
      .function()
      .args(z.string().describe("The city to fetch weather for"))
      .returns(
        z.object({
          location: z.object({
            name: z.string(),
          }),
        }),
      ),
  },
];

// Register your tools with Tambo
<TamboProvider tools={tools}>
  <App />
</TamboProvider>;
```

Now Tambo can fetch weather information for a city when responding to a message!

**When to use local tools:** DOM interactions, wrapping authenticated fetch requests, or accessing React state. Runs entirely in the browser. For server-side integrations with databases, APIs, or file systems, consider using [MCP servers](/concepts/model-context-protocol) instead.

## Returning Rich Content

By default, tool responses are converted to strings and sent back to the AI as text. However, tools can return rich content like images, audio, or mixed media by using the `transformToContent` parameter.

The `transformToContent` function transforms your tool's return value into an array of content parts before sending it back to the AI. This is useful when your tool needs to return images, audio files, or a combination of different content types.

```tsx
import { TamboTool } from "@tambo-ai/react";
import { z } from "zod";

const getProductImage = async (productId: string) => {
  const product = await fetchProductData(productId);
  return {
    name: product.name,
    description: product.description,
    imageUrl: product.imageUrl,
    price: product.price,
  };
};

export const tools: TamboTool[] = [
  {
    name: "get_product_image",
    description: "Fetch product information including image",
    tool: getProductImage,
    toolSchema: z
      .function()
      .args(z.string().describe("Product ID"))
      .returns(
        z.object({
          name: z.string(),
          description: z.string(),
          imageUrl: z.string(),
          price: z.number(),
        }),
      ),
    // Transform the result into content parts
    transformToContent: (result) => [
      {
        type: "text",
        text: `${result.name} - $${result.price}\n\n${result.description}`,
      },
      {
        type: "image_url",
        image_url: { url: result.imageUrl },
      },
    ],
  },
];
```

### Supported Content Types

The `transformToContent` function can return an array of content parts with the following types:

- **Text**: `{ type: "text", text: string }`
- **Image**: `{ type: "image_url", image_url: { url: string } }`
- **Audio**: `{ type: "input_audio", input_audio: { data: string, format: "wav" | "mp3" } }`

You can mix and match these content types to create rich, multimedia responses from your tools.

### When to Use transformToContent

Use `transformToContent` when your tool:

- Returns image URLs that should be displayed inline
- Generates audio that should be played
- Needs to return a combination of text and media
- Integrates with MCP servers (which already return content in this format)

If your tool only returns text or simple data, you don't need `transformToContent` - the default behavior will handle it automatically.
