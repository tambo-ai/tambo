---
title: System Messages
description: Understanding persistent, thread-level instructions
---

import LearnMore from "@/components/learn-more";
import { Rocket } from "lucide-react";

System messages are fundamentally different from other context methods. While context helpers inform each message with current data, system messages *program* the entire conversation. They establish persistent instructions that guide the AI's behavior for the thread's lifetime.

## Programming vs Informing

Think of the difference this way:

**Context helpers** inform each message:
- "It's currently 2:30 PM"
- "The user is on the dashboard page"
- "The selected project is Project Alpha"

**System messages** program the conversation:
- "You are a financial advisor specializing in retirement planning"
- "Always confirm timezone before scheduling"
- "Respond in structured bullet points with confidence levels"

Context helpers provide *data*. System messages provide *instructions*.

## Why Persistent Instructions Matter

Some aspects of the AI's behavior shouldn't change throughout a conversation. Once you establish that the AI is a "data analyst" or a "code reviewer," that role should persist. You shouldn't need to remind it with every message.

System messages solve this by setting instructions once at thread creation. These instructions remain active for every response in that thread.

### Examples of Persistent Instructions

**AI Persona**: "You are a technical support specialist for enterprise software"
- Shapes tone, expertise level, and response style
- Doesn't need to change during the conversation

**Domain Expertise**: "You specialize in healthcare compliance and HIPAA regulations"
- Focuses responses on relevant knowledge
- Maintains consistent expertise throughout

**Behavioral Constraints**: "Keep responses under 3 paragraphs and always cite sources"
- Establishes response format
- Applies to every response

**Response Structure**: "Provide analysis in this format: Executive Summary, Key Findings, Recommendations"
- Defines consistent output structure
- Users know what to expect

## The Programming Model

System messages are like setting parameters for a function that runs throughout the conversation:

```typescript
createThread({
  // Program the conversation:
  role: "financial advisor",
  specialization: "retirement planning",
  constraints: ["balanced advice", "consider risk tolerance"],
  format: ["bullet points", "confidence levels"],
});

// Every response in this thread follows those instructions
```

Once programmed, you don't need to repeat these instructions. The AI maintains them automatically.

## System Messages vs Context Helpers

The key distinction is **persistence vs updates**:

| Aspect | System Messages | Context Helpers |
|--------|----------------|----------------|
| **Set when** | Thread creation | Every message |
| **Lasts for** | Entire conversation | Current message only |
| **Purpose** | Instructions, role, constraints | Dynamic data, state, environment |
| **Can change** | No (fixed after creation) | Yes (updates between messages) |
| **Performance** | Set once, no overhead | Runs on every message |

**System messages**: "This is *who* you are and *how* you behave"

**Context helpers**: "This is *where* the user is and *what* they're doing right now"

## When to Use Each

**Use system messages for:**
- AI persona that doesn't change ("You are a code reviewer")
- Domain expertise that persists ("You specialize in React performance")
- Behavioral rules that always apply ("Always confirm before destructive actions")
- Response format that stays consistent ("Use bullet points for lists")

**Use context helpers for:**
- Current page or route (changes as user navigates)
- Time and timezone (updates with each message)
- Selected items or active project (changes during session)
- User authentication state (updates when they log in/out)

The pattern: if it changes during the conversation, use context helpers. If it defines the conversation, use system messages.

## Multiple System Messages

You can set multiple system messages to separate concerns:

```typescript
Message 1: Role and expertise
"You are a financial advisor specializing in retirement planning"

Message 2: User context (persistent for this thread)
"Current client: Age 45, risk tolerance moderate, 20-year horizon"

Message 3: Behavioral constraints
"Provide balanced advice. Always explain risks. Be conservative with projections."
```

Each message contributes to the persistent instruction set.

## The Conversation "Contract"

Think of system messages as a contract between you and the AI for this specific conversation:

"For this thread, you will:
- Act as [role]
- Specialize in [domain]
- Follow these rules [constraints]
- Format responses like [structure]"

This contract doesn't need renegotiation with each message. It's established upfront and honored throughout.

## Combining with Other Context

System messages work alongside all other context methods:

```
Thread foundation (persistent):
  System message: "You are a scheduling assistant. Confirm timezone."

Message 1 (dynamic):
  Context helpers: Current time = 2 PM PST, Page = /calendar
  User: "Schedule meeting tomorrow morning"

Message 2 (dynamic):
  Context helpers: Current time = 3 PM PST, Page = /meetings
  User: "What's my next meeting?"
```

The system message (scheduling assistant role) persists. The context helpers (time, page) update. Together they provide both consistent behavior and current awareness.

## When System Messages Excel

System messages are particularly valuable for:

**Role-based conversations**: "You are a data analyst" vs "You are a brainstorming partner" - fundamentally different conversation types

**Specialized domains**: "You are an expert in Kubernetes" - maintains expertise without repetition

**Behavioral consistency**: "Always explain your reasoning" - applies to every response

**Output formatting**: "Structure as: Problem → Solution → Trade-offs" - consistent response format

## Limitations

System messages have intentional constraints:

1. **Can't be changed**: Once set, they're fixed for the thread (create a new thread to change them)
2. **Thread-scoped**: Don't carry across different threads
3. **Set at creation**: Must be included when creating the thread
4. **Not for dynamic data**: Don't use them for data that changes (use context helpers instead)

These limitations are by design - system messages establish the foundation, not the details.

## Implementation

Ready to create threads with system messages?

<LearnMore
  title="Set Thread Instructions"
  description="Step-by-step guide to creating threads with system messages"
  href="/guides/additional-context/set-thread-instructions"
  icon={Rocket}
/>
