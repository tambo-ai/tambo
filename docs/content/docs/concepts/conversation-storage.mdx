---
title: Conversation Storage
description: How Tambo automatically persists conversations and makes them accessible across your application
---

Every interaction between a user and Tambo is represented as a conversation, where the user triggers Tambo by sending a message, and Tambo responds by taking some action.

Every conversation with Tambo is automatically stored as a `Thread`. When a user sends a message, Tambo persists the message content, any additional context, and any response message, tools, or components generated by Tambo. You don't need to configure databases or write persistence logic. Threads are immediately available through the React SDK and visible in your project dashboard.

This automatic persistence enables users to return to previous conversations, and the full history informs future Tambo responses.

## Thread Architecture

Threads in Tambo are organized as sequences of messages between users and Tambo.

### Thread Structure

Every thread contains:

- **Messages**: Ordered sequence of user inputs and AI responses
- **Participants**: Users involved in the conversation
- **Status**: Current generation stage (idle, processing, complete, error)
- **Metadata**: Creation time, last update, custom properties
- **Context**: Accumulated state from message history and component interactions

Threads are identified by a unique ID. When the React SDK creates a new thread, it generates this ID and registers it with the storage backend. All subsequent messages reference this thread ID, maintaining conversation continuity.

### Message Structure

Each message in a thread includes:

**Core Properties:**

- **Role**: Who sent the message (`user`, `assistant`, or `system`)
- **Content**: Text, images, or other media
- **Timestamp**: When the message was created
- **Component**: If Tambo generated a component, it's attached to the message

**Components in Messages:**
When Tambo responds with a [generative component](/concepts/generative-interfaces/generative-components), the component definition and props are stored with the message. This allows the component to be re-rendered when loading conversation history. The component becomes part of the permanent conversation record.

**Component State:**
If components use `useTamboComponentState`, that state is also persisted. When re-rendering a thread, components restore their state from storage, showing users exactly what they last saw.

## Storage Location and Access

### Project Storage

Conversations are stored within your Tambo project. Each project maintains its own isolated conversation database. Threads from one project are never visible to another project, providing natural data isolation.

The storage backend handles:

- Persistence of messages and components
- Real-time updates during streaming
- Thread metadata and indexing
- Query and retrieval operations

### Project Dashboard

Your Tambo Cloud dashboard provides visibility into all conversations:

- List of all threads in the project
- Message history for each thread
- Thread metadata and status
- Participant information
- Search and filtering capabilities

This dashboard is useful for monitoring conversations, debugging issues, and understanding how users interact with your application.

### Access Through React SDK

The React SDK provides hooks for accessing stored conversations:

```tsx
import { useTamboThread, useTamboThreads } from "@tambo-ai/react";

// Access current thread
const { thread } = useTamboThread();

// Access all threads for a user
const { threads } = useTamboThreads();
```

The SDK automatically handles:

- Fetching thread data from storage
- Real-time updates as new messages arrive
- Caching to minimize network requests
- Re-rendering when thread state changes

## Building Conversation Interfaces

Tambo provides two paths for building conversation interfaces:

### Pre-built Component Library

Tambo offers ready-to-use UI components for common conversation patterns:

- Chat interfaces with message bubbles
- Thread lists and navigation
- Input forms with file upload
- Status indicators during generation

These components connect directly to the storage layer and handle all data fetching, updates, and rendering. They're designed for quick implementation of standard conversation UIs.

### Custom UI with React SDK

For applications requiring custom interfaces, the React SDK provides direct access to stored conversation data. You can build any UI pattern—chat, canvas, dashboard, or hybrid—while leveraging automatic storage and retrieval.

The SDK provides:

- Hooks to access thread lists and messages
- Functions to send messages and create threads
- Real-time status during AI generation
- Component rendering utilities

Custom UIs have full control over presentation while Tambo handles storage, retrieval, and state management.

## Thread Lifecycle

### Thread Creation

Threads are created in two ways:

**Automatic Creation**: When using `useTamboThread()` without specifying a thread ID, Tambo automatically creates a new thread the first time a message is sent.

**Explicit Creation**: You can create threads programmatically with initial messages, system instructions, or specific metadata.

### Message Flow

When a user sends a message:

1. Message is validated and assigned an ID
2. Message is stored in the thread
3. Message is sent to Tambo's AI
4. AI response streams back in real-time
5. Response chunks are stored as they arrive
6. Generated components are persisted with the message
7. Thread status updates to reflect completion

This flow happens automatically. The React SDK manages the entire process, updating component state as new data arrives.

### Thread Persistence

Threads persist indefinitely within your project. There's no automatic expiration or cleanup. If you need to delete threads, that's controlled through the project dashboard or API.

Message history accumulates over time. Long conversations might impact performance or token limits. Tambo automatically manages context window limits by intelligently summarizing or truncating older messages while preserving critical information.

## Initial State and System Messages

Threads can start with pre-configured state:

**Initial Messages**: Set up the conversation with system instructions, welcome messages, or pre-loaded components. These appear in the thread history and inform the AI's responses.

**System Messages**: Provide instructions that guide AI behavior throughout the conversation. System messages typically explain the AI's role, constraints, or special capabilities.

Initial state is set when creating a thread and applies only to new threads. Existing threads maintain their original configuration.

## Multi-User Threads

Threads can involve multiple users. In collaborative scenarios, several people might send messages to the same thread, creating a shared conversation history.

The storage layer tracks which user sent each message, allowing UIs to display proper attribution. Real-time updates ensure all participants see new messages as they arrive.

Multi-user threads are useful for:

- Team collaboration with AI assistance
- Support conversations with handoffs
- Educational scenarios with multiple students
- Shared workspaces with persistent AI context

## Storage and Privacy

Conversation storage respects user privacy and data ownership:

- Threads are scoped to your project and never shared across projects
- User authentication determines thread access
- Context keys provide row-level security for multi-tenant applications
- Sensitive data in messages is encrypted at rest
- You control data retention policies through project settings

For applications requiring custom storage backends or specific compliance requirements, Tambo supports self-hosting with full control over data persistence.

## Related Concepts

Understanding conversation storage connects to several other Tambo concepts:

- **[Generative Components](/concepts/generative-interfaces/generative-components)**: How components are generated and stored in messages
- **[Interactable Components](/concepts/generative-interfaces/interactable-components)**: How pre-placed components sync state with storage
- **[Component State](/concepts/generative-interfaces/component-state)**: How component state persists across thread renders
- **[Streaming](/concepts/streaming)**: How messages are stored during real-time generation
- **[Additional Context](/concepts/additional-context)**: How context is accumulated and included in storage

import LearnMore from "@/components/learn-more";
import { Rocket } from "lucide-react";

<LearnMore
  title="Build Custom Conversation UI"
  description="Learn how to access stored conversations and build your own interface"
  href="/guides/build-custom-conversation-ui"
  icon={Rocket}
/>
