---
title: Conversation Storage
description: How Tambo automatically persists conversations and makes them accessible across your application
---

Every conversation with Tambo is automatically stored. When a user sends a message, Tambo persists the message content, any additional context, and the complete response including text, tool calls, and generated components. You don't need to configure databases or write persistence logic. Conversations are immediately available through the React SDK and visible in your project dashboard.

This automatic persistence enables users to return to previous conversations, and the full conversation history informs future Tambo responses.

## What Gets Stored

### Threads

Threads are the containers for conversations. Each thread tracks a single conversation with its own unique ID and maintains metadata about that conversation. A thread knows which project it belongs to, when it was created and last updated, and what stage of generation it's currently in (idle, processing, complete, or error).

Threads can include optional metadata like custom properties or a context key for organizing related conversations. When Tambo is generating a response, the thread tracks what stage it's in and provides a human-readable status message describing what's happening.

### Messages

Messages are the actual content within threads. Each message belongs to a specific thread and has a role indicating who sent it: the user, Tambo (assistant), the system (for instructions), or a tool (for function results).

Messages contain content parts that can be text, images, audio, or other media types. When Tambo responds with a [generative component](/concepts/generative-interfaces/generative-components), the component definition and props are attached to the message. This allows the component to be re-rendered when loading conversation history.

If components use `useTamboComponentState` to track state, that state is also persisted with the message. When re-rendering a thread, components restore their state from storage, showing users exactly what they last saw.

Messages can also include additional context that was provided when they were sent, any errors that occurred during generation, and metadata like whether the message was cancelled.

## Accessing Stored Conversations

### Through the React SDK

The React SDK provides hooks for accessing stored conversations. Use `useTamboThread()` to work with the current thread, or `useTamboThreads()` to access all threads for a user:

```tsx
import { useTamboThread, useTamboThreads } from "@tambo-ai/react";

// Access current thread and its messages
const { thread } = useTamboThread();

// Access all stored threads
const { threads } = useTamboThreads();
```

The SDK automatically fetches thread data, provides real-time updates as new messages arrive, caches data to minimize network requests, and triggers re-renders when thread state changes.

### Through the Project Dashboard

Your Tambo Cloud dashboard provides visibility into all conversations stored in your project. You can see the list of all threads, view complete message history for each thread, check thread status and metadata, and search or filter conversations. This is useful for monitoring how users interact with your application and debugging issues.

## Building Conversation Interfaces

Tambo offers pre-built UI components for common conversation patterns like chat interfaces, thread navigation, and input forms. These connect directly to stored conversations and handle all data fetching and rendering automatically.

For custom interfaces, the React SDK provides direct access to stored conversation data. You can build any UI pattern (chat, canvas, dashboard, or hybrid) with full control over presentation while Tambo handles storage and retrieval.

import LearnMore from "@/components/learn-more";
import { Rocket } from "lucide-react";

<LearnMore
  title="Build Custom Conversation UI"
  description="Step-by-step guide to building your own interface with the React SDK"
  href="/guides/build-custom-conversation-ui"
  icon={Rocket}
/>

## How Threads Work

Threads are created automatically when you send the first message, or you can create them explicitly with initial messages and system instructions. Once created, threads persist indefinitely within your project until you delete them through the dashboard or API.

When a user sends a message, it's validated, assigned an ID, and stored in the thread. The AI response then streams back in real-time, with each chunk being persisted as it arrives. Any generated components are attached to the message, and the thread's status updates throughout the generation process.

Threads can involve multiple users in collaborative scenarios. The storage layer tracks which user sent each message, and real-time updates ensure all participants see new messages as they arrive. This is useful for team collaboration, support handoffs, and shared workspaces.

Conversations are isolated to your project. Threads from one project are never visible to another. Context keys provide additional organization and row-level security for multi-tenant applications.

## Related Concepts

- **[Generative Components](/concepts/generative-interfaces/generative-components)** - How components are generated and stored in messages
- **[Interactable Components](/concepts/generative-interfaces/interactable-components)** - How pre-placed components sync state with storage
- **[Component State](/concepts/generative-interfaces/component-state)** - How component state persists across thread renders
- **[Additional Context](/concepts/additional-context)** - How context is accumulated and included in storage
