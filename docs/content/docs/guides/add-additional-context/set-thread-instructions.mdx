---
title: Set Thread Instructions
description: Create threads with persistent system messages that guide AI behavior
---

import LearnMore from "@/components/learn-more";
import { BookOpen } from "lucide-react";

This guide shows you how to create conversation threads with system messages that provide persistent instructions, set AI persona, or establish behavioral constraints for the entire conversation.

<LearnMore
  title="Understanding System Messages"
  description="Learn when to use system messages vs context helpers"
  href="/concepts/additional-context/system-messages"
  icon={BookOpen}
/>

## Prerequisites

- Understanding of message threads (see [Conversation Storage](/concepts/conversation-storage))
- Basic understanding of the `useTamboThread` hook

## Step 1: Import the Required Hook

```tsx
import { useTamboThread } from "@tambo-ai/react";
```

## Step 2: Create a Thread with System Messages

Use the `createThread` function with `initialMessages` containing system role messages:

```tsx
function StartConversation() {
  const { createThread } = useTamboThread();

  const handleStart = async () => {
    await createThread({
      initialMessages: [
        {
          id: crypto.randomUUID(),
          role: "system",
          content: [
            {
              type: "text",
              text: "You are a helpful assistant specialized in data analysis. When analyzing data, always explain your methodology and highlight key insights.",
            },
          ],
          createdAt: new Date().toISOString(),
          componentState: {},
        },
      ],
    });
  };

  return <button onClick={handleStart}>Start Analysis Session</button>;
}
```

## Common Use Cases

### Use Case 1: AI Persona and Expertise

Set the AI's role and domain expertise:

```tsx
const handleStartFinancialAdvisor = async () => {
  await createThread({
    initialMessages: [
      {
        id: crypto.randomUUID(),
        role: "system",
        content: [
          {
            type: "text",
            text: "You are a financial advisor specializing in retirement planning. Provide balanced advice considering both growth and risk management.",
          },
        ],
        createdAt: new Date().toISOString(),
        componentState: {},
      },
    ],
  });
};
```

### Use Case 2: Multiple System Messages

Separate concerns across multiple system messages:

```tsx
const handleStartWithContext = async () => {
  const initialMessages = [
    // Message 1: Role and expertise
    {
      id: crypto.randomUUID(),
      role: "system" as const,
      content: [
        {
          type: "text" as const,
          text: "You are a technical support specialist for enterprise software.",
        },
      ],
      createdAt: new Date().toISOString(),
      componentState: {},
    },
    // Message 2: User context
    {
      id: crypto.randomUUID(),
      role: "system" as const,
      content: [
        {
          type: "text" as const,
          text: `Current user information:
- Account type: Enterprise
- Product version: 2.5.1
- Support tier: Premium
- Industry: Healthcare`,
        },
      ],
      createdAt: new Date().toISOString(),
      componentState: {},
    },
  ];

  await createThread({ initialMessages });
};
```

### Use Case 3: Dynamic System Messages

Generate system messages based on user data:

```tsx
function PersonalizedChatStarter({ userId }: { userId: string }) {
  const { createThread } = useTamboThread();

  const handleStart = async () => {
    const userData = await fetchUserData(userId);

    const systemMessage = {
      id: crypto.randomUUID(),
      role: "system" as const,
      content: [
        {
          type: "text" as const,
          text: `You are assisting ${userData.name}, a ${userData.role} at ${userData.company}.

Expertise level: ${userData.expertiseLevel}
Current projects: ${userData.projects.join(", ")}
Communication style: ${userData.preferences.communicationStyle}

Tailor your responses to match their expertise and communication preferences.`,
        },
      ],
      createdAt: new Date().toISOString(),
      componentState: {},
    };

    await createThread({ initialMessages: [systemMessage] });
  };

  return <button onClick={handleStart}>Start Personalized Chat</button>;
}
```

## Pattern: Role-Based Conversations

Create different conversation types with specialized system messages:

```tsx
function ConversationTypeSelector() {
  const { createThread } = useTamboThread();

  const conversationTypes = {
    analysis: {
      title: "Data Analysis",
      systemMessage: `You are a data analyst. Structure your responses with:
- Executive summary
- Key findings (bullet points)
- Supporting evidence
- Confidence levels
- Actionable recommendations`,
    },
    brainstorm: {
      title: "Brainstorming",
      systemMessage: `You are a creative brainstorming partner.
- Generate diverse, unconventional ideas
- Build on user suggestions with "Yes, and..."
- Combine concepts in novel ways
- Aim for quantity (10+ ideas) before quality`,
    },
    review: {
      title: "Code Review",
      systemMessage: `You are an experienced code reviewer. Focus on:
- Correctness and potential bugs
- Performance implications
- Security vulnerabilities
- Code readability and maintainability
- Best practices and patterns`,
    },
  };

  const startConversation = async (
    type: keyof typeof conversationTypes,
  ) => {
    await createThread({
      initialMessages: [
        {
          id: crypto.randomUUID(),
          role: "system",
          content: [
            {
              type: "text",
              text: conversationTypes[type].systemMessage,
            },
          ],
          createdAt: new Date().toISOString(),
          componentState: {},
        },
      ],
    });
  };

  return (
    <div>
      <h3>Start a Conversation</h3>
      {Object.entries(conversationTypes).map(([key, value]) => (
        <button
          key={key}
          onClick={() =>
            startConversation(key as keyof typeof conversationTypes)
          }
        >
          {value.title}
        </button>
      ))}
    </div>
  );
}
```

## Pattern: Behavioral Constraints

Set specific rules and constraints:

```tsx
const handleStartWithConstraints = async () => {
  await createThread({
    initialMessages: [
      {
        id: crypto.randomUUID(),
        role: "system",
        content: [
          {
            type: "text",
            text: `You are a helpful assistant with the following constraints:
- Keep responses under 3 paragraphs
- Always cite sources when making factual claims
- If uncertain, say "I'm not sure" rather than guessing
- Use bullet points for lists of 3+ items
- Confirm before taking destructive actions`,
          },
        ],
        createdAt: new Date().toISOString(),
        componentState: {},
      },
    ],
  });
};
```

## Combining with Context Helpers

System messages work alongside context helpers for layered context:

```tsx
// System message: Persistent instructions
const systemMessage = {
  id: crypto.randomUUID(),
  role: "system" as const,
  content: [
    {
      type: "text" as const,
      text: "You are a scheduling assistant. Always confirm timezone when discussing times.",
    },
  ],
  createdAt: new Date().toISOString(),
  componentState: {},
};

// Context helpers provide dynamic data
<TamboProvider
  contextHelpers={{
    userTime: currentTimeContextHelper,
    userPage: currentPageContextHelper,
  }}
>
  {/* Create thread with system message */}
</TamboProvider>;
```

Together they provide:
- **System message**: Persistent behavioral instructions
- **Context helpers**: Dynamic environment data (time, page, state)

## Complete Example

Full implementation with conversation type selection and user context:

```tsx
import { useTamboThread } from "@tambo-ai/react";

function ConversationStarter({ user }: { user: User }) {
  const { createThread } = useTamboThread();

  const startSupportConversation = async () => {
    const systemMessages = [
      {
        id: crypto.randomUUID(),
        role: "system" as const,
        content: [
          {
            type: "text" as const,
            text: "You are a friendly technical support specialist. Be patient and thorough.",
          },
        ],
        createdAt: new Date().toISOString(),
        componentState: {},
      },
      {
        id: crypto.randomUUID(),
        role: "system" as const,
        content: [
          {
            type: "text" as const,
            text: `User context:
- Name: ${user.name}
- Account: ${user.accountType}
- Experience level: ${user.experienceLevel}
- Previous issues: ${user.recentIssues.length}`,
          },
        ],
        createdAt: new Date().toISOString(),
        componentState: {},
      },
    ];

    await createThread({ initialMessages: systemMessages });
  };

  return (
    <button onClick={startSupportConversation}>Start Support Chat</button>
  );
}
```

## Next Steps

<LearnMore
  title="Understanding Additional Context"
  description="Learn about other context methods and how they work together"
  href="/concepts/additional-context"
  icon={BookOpen}
/>
