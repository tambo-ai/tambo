---
title: Build Custom Conversation UI
description: Create your own chat interface using the React SDK to access and display stored conversations
---

Tambo provides [pre-built components](https://ui.tambo.co) to help you create common conversation interfaces quickly, but if you prefer to build your own from scratch you can use the React SDK.

The Tambo React SDK provides hooks for accessing stored conversation data, allowing you to build custom interfaces that match your application's design. Whether you're building a traditional chat, a canvas-style workspace, or a hybrid interface, the SDK handles data fetching, real-time updates, and state management while you control the presentation.

This guide walks through building a complete custom conversation interface from scratch.

## Prerequisites

Before building custom conversation UI:

- Understand how [Conversation Storage](/concepts/conversation-storage) works
- Have registered [components](/guides/register-generative-components) with Tambo
- Set up the `TamboProvider` in your application

## Single Conversation Interface

### Display Messages

Show the conversation history using the current thread's messages:

```tsx
import { useTamboThread } from "@tambo-ai/react";

function MessageList() {
  const { thread } = useTamboThread();

  if (!thread) {
    return <div>Loading conversation...</div>;
  }

  return (
    <div className="messages">
      {thread.messages.map((message) => (
        <div key={message.id} className={`message message-${message.role}`}>
          <div className="message-sender">{message.role}</div>

          {/* Render text content */}
          {message.content.map((contentPart, idx) => {
            if (contentPart.type === "text") {
              return <p key={idx}>{contentPart.text}</p>;
            }
            return null;
          })}

          {/* Render component if present */}
          {message.renderedComponent && (
            <div className="message-component">{message.renderedComponent}</div>
          )}
        </div>
      ))}
    </div>
  );
}
```

Messages contain text content, images, and generated components. The `renderedComponent` property contains any component Tambo created in response to the message.

**Alternative: Canvas-Style Display**

For interfaces showing only the latest component (dashboards, workspaces), walk backwards through messages to find the most recent component:

```tsx
import { useTamboThread } from "@tambo-ai/react";

function CanvasView() {
  const { thread } = useTamboThread();

  const latestComponent = thread?.messages
    .slice()
    .reverse()
    .find((message) => message.renderedComponent)?.renderedComponent;

  return (
    <div className="canvas">
      {latestComponent ? (
        latestComponent
      ) : (
        <p>Ask Tambo to create something...</p>
      )}
    </div>
  );
}
```

This pattern is useful when you want a clean workspace that updates with each AI response, rather than showing full conversation history.

### Send Messages

Create an input form that sends messages to the current thread:

```tsx
import { useTamboThreadInput } from "@tambo-ai/react";

function MessageInput() {
  const { value, setValue, submit, isPending, error } = useTamboThreadInput();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!value.trim() || isPending) return;

    await submit({
      streamResponse: true,
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <textarea
        value={value}
        onChange={(e) => setValue(e.target.value)}
        placeholder="Type your message..."
        disabled={isPending}
      />
      <button type="submit" disabled={isPending || !value.trim()}>
        {isPending ? "Sending..." : "Send"}
      </button>
      {error && <div className="error">{error.message}</div>}
    </form>
  );
}
```

The `useTamboThreadInput` hook manages input state and submission, providing the current value, a setter function, a submit function, pending state, and any errors.

For more control over message sending, use `sendThreadMessage` directly:

```tsx
import { useState } from "react";
import { useTamboThread } from "@tambo-ai/react";

function CustomInput() {
  const { sendThreadMessage } = useTamboThread();
  const [input, setInput] = useState("");

  const handleSend = async () => {
    await sendThreadMessage(input, {
      streamResponse: true,
    });
    setInput("");
  };

  return (
    <div>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button onClick={handleSend}>Send</button>
    </div>
  );
}
```

### Show Generation Status

Provide feedback during AI response generation:

```tsx
import { useTamboThread } from "@tambo-ai/react";

function StatusIndicator() {
  const { isProcessing, statusMessage } = useTamboThread();

  if (!isProcessing) {
    return null;
  }

  return (
    <div className="status-indicator">
      <div className="spinner" />
      <p>{statusMessage}</p>
    </div>
  );
}
```

The `statusMessage` is a context-aware string generated by Tambo that describes what's happening. For example: "Looking for a component to help with your request about sales data."

## Multiple Conversations

### Display Thread List

Show users their available conversations:

```tsx
import { useTamboThreads } from "@tambo-ai/react";

function ThreadList() {
  const { threads } = useTamboThreads();

  return (
    <div className="thread-list">
      <h2>Conversations</h2>
      {threads.map((thread) => (
        <div key={thread.id} className="thread-item">
          <h3>{thread.name || "Untitled Conversation"}</h3>
          <p>{new Date(thread.createdAt).toLocaleDateString()}</p>
        </div>
      ))}
    </div>
  );
}
```

The `threads` array contains all stored conversations.

### Switch Between Threads

Allow users to select and view different conversations:

```tsx
import { useTamboThread, useTamboThreads } from "@tambo-ai/react";

function ThreadList() {
  const { threads } = useTamboThreads();
  const { thread: currentThread, switchCurrentThread } = useTamboThread();

  return (
    <div className="thread-list">
      {threads.map((thread) => (
        <button
          key={thread.id}
          onClick={() => switchCurrentThread(thread.id)}
          className={currentThread?.id === thread.id ? "active" : ""}
        >
          {thread.name || "Untitled Conversation"}
        </button>
      ))}
    </div>
  );
}
```

When you switch threads, the entire UI automatically updates to show the new thread's messages and state. The SDK handles fetching the thread data and updating component state.

## Complete Example

Here's a full custom conversation UI combining all the pieces:

```tsx
import {
  useTamboThread,
  useTamboThreads,
  useTamboThreadInput,
} from "@tambo-ai/react";

function ConversationUI() {
  const { threads } = useTamboThreads();
  const { thread, switchCurrentThread, isProcessing, statusMessage } =
    useTamboThread();
  const { value, setValue, submit, isPending } = useTamboThreadInput();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!value.trim() || isPending) return;
    await submit({ streamResponse: true });
  };

  return (
    <div className="conversation-ui">
      {/* Thread List Sidebar */}
      <aside className="threads-sidebar">
        <h2>Conversations</h2>
        {threads.map((t) => (
          <button
            key={t.id}
            onClick={() => switchCurrentThread(t.id)}
            className={thread?.id === t.id ? "active" : ""}
          >
            {t.name || "Untitled Conversation"}
          </button>
        ))}
      </aside>

      {/* Main Conversation Area */}
      <main className="conversation-main">
        {/* Messages */}
        <div className="messages">
          {thread?.messages.map((message) => (
            <div key={message.id} className={`message message-${message.role}`}>
              {message.content.map((part, idx) =>
                part.type === "text" ? <p key={idx}>{part.text}</p> : null,
              )}
              {message.renderedComponent && (
                <div>{message.renderedComponent}</div>
              )}
            </div>
          ))}

          {/* Status Indicator */}
          {isProcessing && (
            <div className="status">
              <div className="spinner" />
              <p>{statusMessage}</p>
            </div>
          )}
        </div>

        {/* Input Form */}
        <form onSubmit={handleSubmit} className="input-form">
          <textarea
            value={value}
            onChange={(e) => setValue(e.target.value)}
            placeholder="Type your message..."
            disabled={isPending}
          />
          <button type="submit" disabled={isPending || !value.trim()}>
            {isPending ? "Sending..." : "Send"}
          </button>
        </form>
      </main>
    </div>
  );
}
```

## Advanced Patterns

### Create Threads with Initial State

To create threads with initial messages or system instructions:

```tsx
import { useTamboThread, TamboThreadMessage } from "@tambo-ai/react";

function NewThreadButton() {
  const { createThread } = useTamboThread();

  const handleNewThread = async () => {
    const initialMessages: TamboThreadMessage[] = [
      {
        id: crypto.randomUUID(),
        role: "system",
        content: [
          {
            type: "text",
            text: "You are a helpful assistant specialized in data analysis.",
          },
        ],
        createdAt: new Date().toISOString(),
        componentState: {},
      },
    ];

    await createThread({ initialMessages });
  };

  return <button onClick={handleNewThread}>New Analysis Session</button>;
}
```

## Related Concepts

- **[Conversation Storage](/concepts/conversation-storage)** - Understanding how threads are persisted
- **[Streaming](/concepts/streaming)** - How real-time responses work
- **[Additional Context](/concepts/additional-context)** - Providing context to improve responses
- **[Component State](/concepts/generative-interfaces/component-state)** - How component state persists across renders
