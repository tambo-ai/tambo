---
title: Register Interactable Components
description: Step-by-step guide to making pre-placed components editable by Tambo through natural language.
---

import LearnMore from "@/components/learn-more";
import { BookOpen } from "lucide-react";

This guide shows you how to register React components as "interactable" so Tambo can modify their props in response to user messages. Unlike generative components that Tambo creates on-demand, interactable components are pre-placed by you and allow Tambo to update them in place.

<LearnMore
  title="Learn more about Interactable components"
  description="Understand what Interactable components are and when to use them"
  href="/concepts/generative-interfaces/interactable-components"
  icon={BookOpen}
/>

## Prerequisites

- A React component you want to make interactable
- A Zod schema defining the component's props
- `@tambo-ai/react` installed in your project
- Your app wrapped with `<TamboProvider>`

## Step 1: Build Your Presentational Component

Create a standard React component that accepts props. Use `useEffect` to sync any local UI state with incoming prop changes from Tambo.

```tsx
import { useEffect, useState } from "react";

type NoteProps = {
  title: string;
  content: string;
  color?: "white" | "yellow" | "blue" | "green";
};

export function Note({ title, content, color = "yellow" }: NoteProps) {
  const [draftContent, setDraftContent] = useState(content);

  // Sync local state when props change from Tambo
  useEffect(() => {
    setDraftContent(content);
  }, [content]);

  return (
    <section className={`note note-${color}`}>
      <h3>{title}</h3>
      <textarea
        value={draftContent}
        onChange={(event) => setDraftContent(event.currentTarget.value)}
      />
    </section>
  );
}
```

**Key points:**

- Component should accept props normally
- Use `useEffect` to mirror prop changes to local state
- Local edits (like textarea changes) stay in component state

## Step 2: Define Your Props Schema

Create a Zod schema that describes which props Tambo can modify:

```tsx
import { z } from "zod";

export const NotePropsSchema = z.object({
  title: z.string(),
  content: z.string(),
  color: z.enum(["white", "yellow", "blue", "green"]).optional(),
});
```

This schema tells Tambo:

- Which props it can update
- What types and values are valid
- Which props are optional

## Step 3: Wrap with `withInteractable`

Use `withInteractable` to create an interactable version of your component:

```tsx
import { withInteractable } from "@tambo-ai/react";
import { Note } from "./note";
import { NotePropsSchema } from "./note-schema";

export const InteractableNote = withInteractable(Note, {
  componentName: "Note",
  description:
    "A simple note that can change title, content, and background color",
  propsSchema: NotePropsSchema,
});
```

**Configuration options:**

- `componentName`: Name Tambo uses to reference this component
- `description`: What the component does (helps Tambo decide when to use it)
- `propsSchema`: Zod schema defining editable props

<Callout type="info" title="Automatic Registration">

Unlike generative components, interactable components register themselves automatically when they mount. You don't need to add them to `TamboProvider`'s components array.

</Callout>

## Step 4: Render in Your App

Place the interactable component in your app where you want it to appear, within the `TamboProvider`:

```tsx
import { TamboProvider } from "@tambo-ai/react";
import { InteractableNote } from "./interactable-note";

function App() {
  return (
    <TamboProvider>
      <main>
        <InteractableNote
          title="Release plan"
          content="Ask Tambo to keep this note up to date."
          color="yellow"
        />
      </main>
    </TamboProvider>
  );
}
```

Tambo can now see and modify this component when users send messages like:

- "Change the note title to 'Important Reminder'"
- "Update the note content to 'Don't forget the meeting at 3pm'"
- "Make the note blue"

## Complete Example

Here's a complete working example:

```tsx
import { useEffect, useState } from "react";
import { withInteractable, TamboProvider } from "@tambo-ai/react";
import { z } from "zod";

// Step 1: Presentational component
type NoteProps = {
  title: string;
  content: string;
  color?: "white" | "yellow" | "blue" | "green";
};

function Note({ title, content, color = "yellow" }: NoteProps) {
  const [draftContent, setDraftContent] = useState(content);

  useEffect(() => {
    setDraftContent(content);
  }, [content]);

  return (
    <section className={`note note-${color}`}>
      <h3>{title}</h3>
      <textarea
        value={draftContent}
        onChange={(event) => setDraftContent(event.currentTarget.value)}
      />
    </section>
  );
}

// Step 2 & 3: Schema and wrap with withInteractable
const NotePropsSchema = z.object({
  title: z.string(),
  content: z.string(),
  color: z.enum(["white", "yellow", "blue", "green"]).optional(),
});

const InteractableNote = withInteractable(Note, {
  componentName: "Note",
  description:
    "A simple note that can change title, content, and background color",
  propsSchema: NotePropsSchema,
});

// Step 4: Use in app
export default function Page() {
  return (
    <TamboProvider>
      <main>
        <InteractableNote
          title="Release plan"
          content="Ask Tambo to keep this note up to date."
          color="yellow"
        />
      </main>
    </TamboProvider>
  );
}
```

## Partial Updates and Property Replacement

Understanding how Tambo updates interactable component props is important for avoiding unexpected behavior.

### How Updates Work

Interactable components use **property replacement** for updates, not deep merging:

- **Top-level props** are replaced individually
- **Nested objects** are replaced entirely, not merged
- **Arrays** are replaced entirely when updated

```tsx
// Original props
{
  title: "Original Title",
  config: {
    theme: "light",
    language: "en",
    features: { notifications: true, analytics: false },
  },
}

// Update with nested object that omits some keys
{
  config: { theme: "dark" }
}

// Result: entire config object is replaced
{
  title: "Original Title",
  config: {
    theme: "dark",
    // language and features are now undefined
  },
}
```

### Best Practices

When updating nested properties, provide the complete nested object to preserve other fields:

```tsx
// ✅ Good: Full nested object preserves all fields
{
  config: {
    theme: "dark",
    language: "en",
    features: { notifications: true, analytics: false },
  },
}

// ❌ Poor: Partial nested object loses other fields
{
  config: { theme: "dark" }
}
```

**Tips:**

- Keep nested structures shallow when possible
- Group related props that should update together
- For complex state, consider flattening the prop structure

## Customizing Automatic Context

By default, all interactable components are automatically included in the AI's context. This can be customized or disabled if needed.

### Disable Context Globally

To disable interactables context across your entire app:

```tsx
<TamboProvider
  apiKey={apiKey}
  contextHelpers={{
    // Disable interactables context globally
    interactables: () => null,
  }}
>
  <TamboInteractableProvider>
    {/* Components still work, but aren't visible in AI context */}
    <InteractableNote title="Hidden from AI" />
  </TamboInteractableProvider>
</TamboProvider>
```

### Enable Context Locally

If you've disabled context globally but want to enable it for a specific page:

```tsx
import {
  useTamboContextHelpers,
  useCurrentInteractablesSnapshot,
} from "@tambo-ai/react";

function SpecificPage() {
  const { addContextHelper } = useTamboContextHelpers();
  const snapshot = useCurrentInteractablesSnapshot();

  React.useEffect(() => {
    // Re-enable interactables context for this page only
    const helper = () => {
      if (snapshot.length === 0) return null;

      return {
        description: "Interactable components on this page that you can modify",
        components: snapshot.map((component) => ({
          id: component.id,
          componentName: component.name,
          description: component.description,
          props: component.props,
        })),
      };
    };

    addContextHelper("interactables", helper);
  }, [addContextHelper, snapshot]);

  return (
    <TamboInteractableProvider>
      <InteractableNote title="Visible to AI" />
    </TamboInteractableProvider>
  );
}
```

### Share Only Component IDs

For privacy or token optimization, share only IDs and names, letting the AI request full details when needed:

```tsx
import {
  useCurrentInteractablesSnapshot,
  useTamboContextHelpers,
} from "@tambo-ai/react";

function IdsOnlyContext() {
  const { addContextHelper } = useTamboContextHelpers();
  const snapshot = useCurrentInteractablesSnapshot();

  React.useEffect(() => {
    const idsOnlyHelper = () => {
      if (snapshot.length === 0) return null;

      return {
        description: "Available interactable component IDs.",
        components: snapshot.map((component) => ({
          id: component.id,
          componentName: component.name,
          // Deliberately omit props
        })),
      };
    };

    addContextHelper("interactables", idsOnlyHelper);
  }, [addContextHelper, snapshot]);

  return null; // This component just configures context
}

// Usage
<TamboInteractableProvider>
  <IdsOnlyContext />
  <InteractableNote title="Props not visible unless requested" />
</TamboInteractableProvider>;
```

### Filter by Component Type

Show only specific component types in the AI context:

```tsx
function FilteredContext() {
  const { addContextHelper } = useTamboContextHelpers();
  const snapshot = useCurrentInteractablesSnapshot();

  React.useEffect(() => {
    const filteredHelper = () => {
      // Only show Notes, hide other component types
      const allowedTypes = ["Note"];
      const filteredComponents = snapshot.filter((component) =>
        allowedTypes.includes(component.name),
      );

      if (filteredComponents.length === 0) return null;

      return {
        description: "Available interactable components (filtered)",
        components: filteredComponents.map((component) => ({
          id: component.id,
          componentName: component.name,
          props: component.props,
        })),
      };
    };

    addContextHelper("interactables", filteredHelper);
  }, [addContextHelper, snapshot]);

  return null;
}
```

## Accessing Component Metadata

When building components inside interactables (like inline editors or toolbars), you can access the parent component's metadata using specialized hooks.

### useTamboCurrentComponent

Access the parent interactable component's metadata from any nested child:

```tsx
import { useTamboCurrentComponent } from "@tambo-ai/react";

function InlineEditor() {
  const component = useTamboCurrentComponent();

  if (!component) {
    return null; // Not inside a component context
  }

  return (
    <div className="inline-editor">
      <h4>Editing: {component.componentName}</h4>
      {component.interactableId && (
        <span className="badge">ID: {component.interactableId}</span>
      )}
    </div>
  );
}
```

**Return Value:**

The hook returns an object with these fields, or `null` if used outside a component context:

| Field            | Type                               | Description                                              |
| ---------------- | ---------------------------------- | -------------------------------------------------------- |
| `componentName`  | `string \| undefined`              | The component's registered name                          |
| `props`          | `Record<string, any> \| undefined` | The component's current props                            |
| `interactableId` | `string \| undefined`              | Unique identifier (only for interactable components)     |
| `description`    | `string \| undefined`              | Component description (only for interactable components) |

### Pattern 1: Inline AI Editor

Build an inline editor that automatically adapts to its parent component:

```tsx
import { useTambo, useTamboCurrentComponent } from "@tambo-ai/react";
import { useState } from "react";

function InlineAIEditor() {
  const component = useTamboCurrentComponent();
  const { sendThreadMessage } = useTambo();
  const [prompt, setPrompt] = useState("");
  const [isEditing, setIsEditing] = useState(false);

  if (!component) return null;

  const handleEdit = async () => {
    await sendThreadMessage(prompt, {
      additionalContext: {
        inlineEdit: {
          componentId: component.interactableId,
          componentName: component.componentName,
          currentProps: component.props,
        },
      },
    });
    setPrompt("");
    setIsEditing(false);
  };

  return (
    <div className="inline-editor">
      {!isEditing ? (
        <button onClick={() => setIsEditing(true)}>✨ Edit with AI</button>
      ) : (
        <div className="editor-form">
          <input
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            placeholder={`Edit ${component.componentName}...`}
          />
          <button onClick={handleEdit}>Apply</button>
          <button onClick={() => setIsEditing(false)}>Cancel</button>
        </div>
      )}
    </div>
  );
}

// Use in any interactable component
const InteractableCard = withInteractable(Card, {
  componentName: "Card",
  description: "A card component with title and content",
  propsSchema: cardSchema,
});

function Card({ title, content }) {
  return (
    <div className="card">
      <h3>{title}</h3>
      <p>{content}</p>
      <InlineAIEditor /> {/* Automatically knows it's in a Card */}
    </div>
  );
}
```

### Pattern 2: Component-Aware Toolbar

Create a reusable toolbar that adapts based on the component it's in:

```tsx
import { useTamboCurrentComponent } from "@tambo-ai/react";

function ComponentToolbar() {
  const component = useTamboCurrentComponent();

  if (!component?.interactableId) {
    return null; // Only show for interactable components
  }

  const handleDuplicate = () => {
    console.log("Duplicating", component.componentName, component.props);
  };

  const handleDelete = () => {
    console.log("Deleting", component.interactableId);
  };

  return (
    <div className="toolbar">
      <span className="component-name">{component.componentName}</span>
      <button onClick={handleDuplicate}>Duplicate</button>
      <button onClick={handleDelete}>Delete</button>
    </div>
  );
}

// Works in any interactable component without modifications
const InteractableNote = withInteractable(Note, {
  componentName: "Note",
  description: "A note component",
  propsSchema: noteSchema,
});

function Note({ title, content }) {
  return (
    <div>
      <ComponentToolbar /> {/* Automatically adapts to Note */}
      <h3>{title}</h3>
      <p>{content}</p>
    </div>
  );
}
```

### Pattern 3: Dynamic UI Based on Props

Show different controls based on the component's current props:

```tsx
import { useTamboCurrentComponent } from "@tambo-ai/react";

function StatusBadge() {
  const component = useTamboCurrentComponent();

  if (!component?.props) return null;

  // Access current props to show relevant UI
  const status = component.props.status;
  const priority = component.props.priority;

  return (
    <div className="status-bar">
      {status && <Badge variant={status}>{status}</Badge>}
      {priority && <PriorityIcon level={priority} />}
      <span className="component-type">{component.componentName}</span>
    </div>
  );
}

const InteractableTask = withInteractable(Task, {
  componentName: "Task",
  description: "A task item",
  propsSchema: z.object({
    title: z.string(),
    status: z.enum(["todo", "in-progress", "done"]),
    priority: z.enum(["low", "medium", "high"]).optional(),
  }),
});

function Task({ title, status, priority }) {
  return (
    <div className="task">
      <StatusBadge /> {/* Automatically shows correct status */}
      <h4>{title}</h4>
    </div>
  );
}
```

### useCurrentInteractablesSnapshot

Get a snapshot of all interactable components currently on the page:

```tsx
import {
  useCurrentInteractablesSnapshot,
  useTamboContextHelpers,
} from "@tambo-ai/react";

function InteractablesDebugPanel() {
  const snapshot = useCurrentInteractablesSnapshot();

  return (
    <div>
      <h3>Components on Page: {snapshot.length}</h3>
      <ul>
        {snapshot.map((component) => (
          <li key={component.id}>
            {component.name} - {component.id}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

This hook returns a cloned snapshot to prevent accidental mutation of internal state. Each item includes:

- `id`: Unique component identifier
- `name`: Component name
- `description`: Component description
- `props`: Current prop values
- `propsSchema`: Zod schema (if available)
