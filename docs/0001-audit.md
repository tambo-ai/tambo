# Tambo AI Monorepo Architecture Audit

**Date**: December 2024
**Scope**: Full Turborepo monorepo covering React SDK, CLI, Showcase, Docs, Tambo Cloud platform (API, Web), and shared packages

---

## Executive Summary

Tambo AI is a well-structured, mature monorepo with strong architectural foundations, excellent tooling discipline, and professional development practices. The codebase demonstrates:

- **Strong TypeScript discipline**: Zero type errors, strict configuration across the board
- **Clean CI/CD practices**: Passing lint, type checks, and tests with Turborepo caching
- **Clear separation of concerns**: Framework packages (SDK, CLI, Docs) separate from Cloud platform (API, Web)
- **Thoughtful documentation**: AGENTS.md files at multiple levels guide development with clarity
- **Professional governance**: Conventional commits, release-please automation, Charlie (AI review agent)

The primary opportunities are around testing coverage expansion, documentation completeness in the Cloud platform, and architectural simplification in certain integration points.

---

## Architecture Assessment

### Overall Structure: SOLID

The monorepo splits into two distinct domains:

#### **Framework Packages** (Turborepo root)

- `react-sdk/` – Main React SDK for AI-powered generative UI (@tambo-ai/react, v0.65.2)
- `cli/` – Command-line tools for project scaffolding and component generation (tambo v0.42.0)
- `showcase/` – Next.js demo app with auto-synced components from CLI registry
- `docs/` – Documentation site (Fumadocs) with comprehensive guides and API reference
- `create-tambo-app/` – App bootstrapper for new projects
- `community/` – Event materials and community resources
- `packages/` – Shared configs (ESLint, TypeScript)

**Assessment**: Clean separation. The registry sync pattern (CLI → Showcase) is elegant and well-tested. Documentation-first approach is professional.

#### **Tambo Cloud Platform** (apps/ + packages/)

- `apps/api/` – NestJS API with OpenAPI spec, Langfuse/Sentry instrumentation
- `apps/web/` – Next.js dashboard UI (tRPC, Tailwind/Shadcn)
- `packages/db/` – Drizzle ORM schema as single source of truth
- `packages/core/` – Shared pure utilities (no DB, clean separation)
- `packages/backend/` – LLM/agent-side streaming helpers
- `packages/testing/` – Jest test utilities
- `packages/eslint-config`, `packages/typescript-config` – Shared tooling

**Assessment**: Well-organized with clear boundaries. DB package as the central schema is a sound pattern. Core/Backend separation properly isolates concerns.

### Dependency Management: STRONG

**Strengths**:

- Workspace protocol (`*`) used correctly for inter-package dependencies
- Peer dependencies declared appropriately in SDK (React 18/19)
- External SDK (`@tambo-ai/typescript-sdk`) is auto-generated by Stainless, not hand-edited
- Volta locks Node 22.21.0 and npm 11.6.2 globally for consistency
- ESM/CJS dual build outputs in React SDK support broad compatibility

**Observations**:

- Heavy but justified dependency graph in apps/web (Radix UI, Tailwind, Recharts, Tiptap, etc.) — typical for a full-featured dashboard
- MCP SDK (`@modelcontextprotocol/sdk`) integrated at multiple levels (React SDK, API, Web)

### Build & Task Pipeline: EXCELLENT

**Turbo Configuration** (`turbo.json`) demonstrates sophisticated orchestration:

```
- Build tasks with dependency graphs (e.g., @tambo-ai/showcase#build depends on //#sync:showcase)
- Cache-busting for component sync (cache: false)
- Persistent dev tasks for watchers
- Global env variables properly declared (60+ environment variables)
- Task-specific outputs (dist/, esm/, .next/)
```

**Build Outputs**:

- React SDK produces both CommonJS (`dist/`) and ESM (`esm/`) — a deliberate choice for maximum compatibility
- Apps use Next.js `standalone` builds suitable for containerization
- CLI distributed as ESM executable

---

## Code Quality & Standards

### TypeScript Discipline: EXCELLENT

**Observations**:

- **Zero type errors**: Full `npm run check-types` passes across all 15 packages in ~19 seconds
- **Strict TypeScript configuration** applied uniformly (visible in package.json comments about tsconfig extends)
- **Type inference used well**: Provider patterns use generic composition (`TamboProvider<TamboClientProviderProps & TamboRegistryProviderProps & ...>`)
- **No `any` types visible** in sampled code (e.g., `threads.ts`, `tambo-provider.tsx`)
- **Zod for runtime validation**: Proper use of schema validation with `z.infer<typeof schema>` patterns

**Code Sample Analysis** (`packages/core/src/threads.ts`):

```typescript
// Proper enum usage for roles and content types
export enum MessageRole { User = "user", Assistant = "assistant", ... }
export enum ContentPartType { Text = "text", ImageUrl = "image_url", ... }

// Type-safe content parts with union types
export type ChatCompletionContentPartText = OpenAI.Chat.Completions.ChatCompletionContentPartText;
export type ChatCompletionContentPartImage = ...;
```

Clean, explicit, no shortcuts.

### Linting & Code Style: EXCELLENT

- **ESLint passes completely** across all packages (cache hit: 0, executed: 15)
- **Prettier formatting** enforced via lint-staged (configured in package.json)
- **Shared ESLint config** (`@tambo-ai/eslint-config`) applied consistently across all packages
- **Plugin usage**: `eslint-plugin-react`, `eslint-plugin-react-hooks`, `eslint-plugin-jsdoc` active in React SDK

**Observation**: No linting issues means either (1) excellent discipline from developers, or (2) rules are too lenient. Recommend spot-checking a few packages to confirm rules match intent.

### Testing: MODERATE

**Strengths**:

- Tests present in strategic areas:
  - React SDK: Hook tests, provider tests, utility tests (e.g., `content-parts.test.ts`, `validate-zod-schema.test.ts`)
  - CLI: Command tests, component registry tests (e.g., `scrollable-message-container.test.tsx`)
  - Core: JSON schema strictness tests, encryption tests
- Test files co-located with source (e.g., `foo.test.ts` next to `foo.ts`)
- Jest with React Testing Library configured properly
- Jest passes with no failures: `npm test` runs successfully

**Gaps**:

- **Coverage unclear**: No coverage reports visible in package.json scripts (test:cov exists but not in standard test)
- **API tests minimal**: `apps/api/` has a test directory but limited coverage evidence
- **Web app tests limited**: `apps/web/` has jest.config.ts but test count unknown
- **Integration tests sparse**: No clear pattern for testing cross-package workflows

**Recommendation**: Run `npm test -- --coverage` to establish baseline coverage metrics.

### Component Architecture: STRONG

**React SDK Pattern** (from AGENTS.md and source):

The nested provider hierarchy in `TamboProvider`:

1. **TamboClientProvider** – API client, auth, sessions
2. **TamboRegistryProvider** – Component/tool registration
3. **TamboContextHelpersProvider** – Context utilities
4. **TamboThreadProvider** – Conversation threads
5. **TamboThreadInputProvider** – User input handling
6. **TamboComponentProvider** – Component lifecycle
7. **TamboInteractableProvider** – Interactive component tracking

**Assessment**: This is a mature pattern. It's complex but justified by the feature set. Each provider is single-purpose. The nesting order matters for dependency flow, which is documented.

**Potential Concern**: The depth of nesting might become a maintenance burden if more providers are added. Consider whether some of these should be combined or made optional.

---

## Development Workflow & Documentation

### Documentation Quality: STRONG

**Multi-Level Documentation Strategy**:

1. **Root-level guides**: AGENTS.md (canonical), CLAUDE.md, CONTRIBUTING.md, README.md
2. **Package-level guides**: Each major package has its own AGENTS.md and README.md
3. **Developer docs**: `devdocs/` with LOADING_STATES.md, NAMING_CONVENTIONS.md, CLAUDE_SKILLS.md
4. **Public docs**: `docs/` Fumadocs site with guides and API reference
5. **Inline JSDoc**: React SDK has detailed JSDoc comments on exported functions

**AGENTS.md as Canonical Source**:
The decision to make AGENTS.md the single source of truth for architectural guidance, naming conventions, and development rules is excellent. It eliminates ambiguity and makes onboarding clear.

**Gaps**:

- `apps/api/` and `apps/web/` lack detailed AGENTS.md files (only found in framework packages)
- API architecture and service organization not well-documented
- Web app component patterns not explicitly documented
- Migration strategy for Drizzle not covered in AGENTS.md (only in README)

### Naming Conventions: WELL-DEFINED

From AGENTS.md:

- **Files/dirs**: kebab-case
- **Classes**: PascalCase
- **Vars/functions**: camelCase
- **ENV vars**: UPPER_SNAKE_CASE
- **React components**: TamboXxx
- **React hooks**: useTamboXxx
- **Props interfaces**: TamboXxxProps
- **Event handlers**: onX, internal handlers: handleX

**Observation**: This is thorough and well-communicated. Sampled code (react-sdk, CLI) follows these conventions consistently.

### Development Workflow: PROFESSIONAL

**Checklist-driven PRs**:

- Conventional Commit titles required (feat, fix, perf, docs, chore, etc.)
- Charlie (AI review agent) integrated into workflow
- Visual changes require ≤90s demo video
- All tests, lint, and types must pass before merge
- Semantic versioning inferred from commit titles

**Process Observation**: This is a mature, well-governed process. The requirement for docs alongside code is professional.

---

## Testing Strategy Analysis

### Current State

**Test Categories Observed**:

1. **Unit tests**: Hook logic, utility functions, provider behavior
2. **Component tests**: React Testing Library with mocks
3. **Integration tests**: Limited evidence (threads API test directory exists)
4. **E2E tests**: None visible

**Test Framework**: Jest + React Testing Library

### Gaps

1. **No coverage requirements enforced**
   - `test:cov` script exists but not in pre-commit or CI
   - No visible coverage thresholds in jest.config.ts files

2. **Limited backend testing**
   - API endpoints not fully tested (observable from minimal test files)
   - NestJS guards/middleware tests missing
   - Service-level business logic tests sparse

3. **No e2e testing**
   - Showcase app not tested end-to-end
   - No user journey testing
   - No cross-package integration tests

4. **Web app testing minimal**
   - Dashboard components untested
   - User flows untested
   - Form interactions untested

### Strength

- **Good unit test practices** in React SDK hooks and utilities
- **Test cohabitation** with source files is excellent for maintainability
- **Jest setup** is professional (jsdom, ts-jest, @testing-library/react)

---

## Database Architecture

### Drizzle ORM: SOUND

**Strengths**:

- `packages/db/src/schema.ts` as single source of truth (31KB of schema definition)
- Migrations auto-generated via `npm run db:generate` (no hand-written SQL)
- Proper Drizzle Studio support for introspection
- Separate operations layer for complex queries

**Observations**:

- Schema is comprehensive (projects, threads, users, oauth, API keys, provider keys, etc.)
- Type-safe schema inference via Drizzle
- Database helpers co-located in db package

**Potential Concern**:

- Schema file is very large (31KB). Consider breaking into logical modules (users, projects, threads, oauth) for readability, though Drizzle's single-schema approach is also valid.

---

## API & Backend Architecture

### NestJS API Structure: ORGANIZED

**Module Organization**:

```
apps/api/src/
├── ai/              # AI service integration
├── audio/           # Audio processing
├── common/          # Shared filters, middleware, services
├── extractor/       # Content extraction
├── mcp-server/      # MCP protocol server
├── oauth/           # OAuth handling
├── projects/        # Project management (controllers, DTOs, guards)
├── registry/        # Component registry
├── scheduler/       # Background jobs
├── threads/         # Thread/conversation management
├── users/           # User management
└── main.ts          # Bootstrap
```

**Assessment**: Clear module boundaries. Each domain owns its DTOs, controllers, and entities. Good separation.

**Implementation Observations**:

- Guards pattern used for authentication (`apikey.guard.ts`, `bearer-token.guard.ts`, `project-access-own.guard.ts`)
- DTOs properly defined for input validation
- OpenAPI/Swagger integration via `@nestjs/swagger`
- Sentry instrumentation for error tracking
- Langfuse integration for observability

**Gaps**:

- No AGENTS.md for API, so architectural decisions not documented
- Service layer organization not clear from directory structure alone
- Test coverage for API unclear (test/ directory exists but minimal evidence of tests)

### Backend Streaming: PRESENT

From `packages/backend`, there are streaming utilities for LLM responses. The React SDK integrates with this via the Tambo TypeScript SDK.

---

## Frontend Architecture

### Next.js Dashboard (apps/web)

**Structure**:

```
apps/web/
├── app/             # Next.js App Router pages and layouts
├── components/      # React components (27 directories)
├── hooks/           # Custom React hooks
├── lib/             # Utilities and helpers (28 files)
├── providers/       # Context and state providers
├── server/          # Server-side utilities
├── styles/          # Tailwind and global CSS
├── trpc/            # tRPC router and procedures
└── types/           # TypeScript types
```

**Tech Stack**:

- Next.js 15.5.6 with App Router
- React 18.3.1
- tRPC 11.7.2 for end-to-end type safety
- Tailwind CSS with Shadcn UI components (Radix UI primitives)
- NextAuth.js for authentication
- React Query for data fetching
- Framer Motion for animations
- Tiptap for rich text editing
- Recharts for charting

**Assessment**:

- Modern, well-chosen stack
- Server components possible via App Router
- tRPC provides excellent DX for API communication
- Component library (Shadcn) reduces custom CSS
- Accessibility primitives (Radix UI) are strong

**Concerns**:

- No AGENTS.md for web, so component structure not formally documented
- Large component directory (27 folders) needs organization clarity
- Testing minimal for UI components
- Form handling patterns (react-hook-form) not documented

---

## Shared Packages Assessment

### packages/core: WELL-DESIGNED

Pure utility functions without database dependency:

- `threads.ts` – Thread message types and enums
- `encrypt.ts` – Encryption utilities with proper testing
- `json.ts` – JSON parsing with error handling
- `mcp-client.ts` – MCP protocol client implementation
- `strictness/json-schema.ts` – JSON schema validation for AI strictness

**Strengths**:

- No external dependencies beyond essentials
- Well-tested (async-queue, encrypt have full test suites)
- Clear separation from database
- Single responsibility per file

### packages/backend: PURPOSE-CLEAR

LLM/agent-specific utilities:

- Streaming response handling
- Tool execution orchestration
- Context building for AI

**Assessment**: Appropriately scoped.

### packages/testing: MINIMAL

Simple Jest utilities for shared test setup.

---

## Security & Secrets Management

### Observations

**Strengths**:

- Environment variables properly declared in turbo.json globalEnv
- Secrets documented in .env files (not committed)
- .env.example files provided as templates
- NextAuth.js for authentication
- Bearer token guards on API endpoints
- API key guards for project access

**No Visible Issues**:

- No hardcoded credentials in sampled code
- Encryption utilities properly implemented (packages/core/src/encrypt.ts)
- OAuth validation present (oauth-validation.ts)

**Recommendations**:

- Ensure .env files are in .gitignore (they are)
- Consider adding secrets rotation documentation
- Validate that API key rotation is part of the security posture

---

## Tooling & DevOps

### Turborepo: WELL-CONFIGURED

- Cache strategy is thoughtful (some tasks disable cache like //#sync:showcase)
- Parallel execution maximized
- Task dependencies explicitly declared
- Output paths configured correctly

### Docker & Deployment

- `Dockerfile` present in apps/web and apps/api
- `docker-compose.yml` for local development
- `scripts/cloud/` helpers for Docker workflows
- Vercel deployment configuration (.vercel/ directory)

**Observation**: Containerization-ready. Cloud-native setup is present.

### CI/CD Tooling

- GitHub Actions workflow referenced (.github/workflows/)
- Conventional commits enforced via `.github/workflows/conventional-commits.yml`
- Release-please for automated versioning (.release-please-manifest.json)
- Charlie (AI code review agent) integrated

---

## Identified Strengths

1. **Architecture Clarity**: Clean separation between Framework (SDK/CLI/Docs) and Cloud (API/Web) domains
2. **TypeScript Discipline**: Zero type errors, strict configuration, no `any` types
3. **Documentation Excellence**: AGENTS.md as authoritative guide, multi-level documentation strategy
4. **Professional Workflow**: Conventional commits, Charlie review agent, video demo requirements
5. **Dependency Management**: Workspace protocol used correctly, external SDKs properly managed
6. **Code Style Consistency**: ESLint passing, Prettier configured, naming conventions enforced
7. **Build Pipeline**: Sophisticated Turbo configuration with caching and dependency tracking
8. **Dual Build Outputs**: React SDK supports both CJS and ESM for broad compatibility
9. **Component Sync**: Elegant CLI registry → Showcase pattern for keeping UI demos in sync
10. **Database Hygiene**: Drizzle ORM as single source of truth, migrations auto-generated

---

## Identified Weaknesses

1. **Testing Coverage Gaps**
   - No coverage requirements enforced
   - API endpoint testing minimal
   - Web app UI testing nearly absent
   - No e2e tests
   - Integration test patterns unclear

2. **API Documentation Deficiency**
   - No AGENTS.md for apps/api
   - API architecture not formally documented
   - Service organization implicit, not explicit

3. **Web App Documentation Deficiency**
   - No AGENTS.md for apps/web
   - Component structure not documented
   - Form handling patterns not documented
   - Custom hooks not catalogued

4. **Provider Hierarchy Complexity**
   - TamboProvider wraps 7 nested providers (TamboClientProvider, TamboRegistryProvider, etc.)
   - Depth may increase maintenance burden
   - Opportunity to consolidate or make optional

5. **Database Schema Readability**
   - `schema.ts` is 31KB in a single file
   - Could benefit from logical module separation (users, projects, threads, oauth)
   - Not a blocker, but impacts cognitive load

6. **Testing Patterns Not Standardized**
   - Different test organization across packages (some use co-location, some use **tests**)
   - No shared testing utilities documented
   - Fixture/mock patterns not consistent

7. **API Key & Project Access Patterns**
   - Multiple guard implementations (apikey.guard.ts, bearer-token.guard.ts, project-access-own.guard.ts)
   - Opportunity to consolidate authentication logic

8. **Performance Monitoring**
   - Sentry and Langfuse integrated, but observability strategy not documented
   - No performance budgets visible

---

## Recommendations: Immediate Actions (High Impact, Low Effort)

### 1. Add AGENTS.md to Cloud Platform Apps

- Create `apps/api/AGENTS.md` documenting:
  - Module organization and responsibilities
  - Service layer patterns
  - Guard/middleware usage
  - Testing expectations
  - Database seeding strategies

- Create `apps/web/AGENTS.md` documenting:
  - Component organization (tRPC-based patterns vs static content)
  - Hook patterns and shared state management
  - Form handling with react-hook-form
  - Testing patterns for components
  - Server vs client component boundaries

**Effort**: 4-6 hours
**Impact**: Removes ambiguity, improves onboarding, aligns team on patterns

### 2. Establish Coverage Baseline & Thresholds

```bash
npm test -- --coverage
# Document the baseline
# Set thresholds in jest.config.ts (recommend: 70% statement, 50% branch)
```

**Effort**: 2-3 hours
**Impact**: Creates accountability for testing

### 3. Add API Testing Examples

Document and implement test patterns for:

- NestJS controller tests (using `@nestjs/testing`)
- Guard tests
- Service tests

Add to `apps/api/AGENTS.md` with examples.

**Effort**: 3-4 hours
**Impact**: Makes API testing discoverable and lowers barrier to testing

### 4. Document Observability Strategy

Create `devdocs/OBSERVABILITY.md` explaining:

- Sentry setup (error tracking, performance monitoring)
- Langfuse setup (LLM observability)
- Metric collection points
- Log aggregation strategy
- On-call runbooks for common issues

**Effort**: 3-4 hours
**Impact**: Enables team to maintain and debug production issues

---

## Recommendations: Medium-Term Improvements (Strategic)

### 5. Reduce TamboProvider Nesting Complexity

**Current State**: 7 nested providers
**Proposed Approach**:

- Keep core providers: TamboClientProvider, TamboRegistryProvider, TamboThreadProvider
- Consolidate optional features (context helpers, interactables) into a single feature provider
- Make streaming prop status optional via hook (useOptionalTamboStreamStatus)

**Benefit**: Simplified mental model for consumers, easier to maintain

**Effort**: 2-3 days (requires API review, backward compatibility checks)

### 6. Consolidate Authentication Guards in API

**Current State**: Three separate guard implementations
**Proposed Approach**:

- Create a `common/guards/auth.guard.ts` that handles all auth strategies
- Use guard metadata to specify required auth type (API key, bearer, project-owned)
- Reduce duplication

**Benefit**: Single source of truth for authentication, easier to audit security

**Effort**: 1-2 days

### 7. Implement Comprehensive Integration Tests

Create `__tests__/integration/` directory with scenarios:

- User creation → Project creation → Thread creation → Message submission
- API key generation and validation
- OAuth flow end-to-end
- Component registry sync (CLI → Showcase)
- tRPC router calls

**Effort**: 1 week
**Impact**: High confidence in cross-package workflows

### 8. Refactor Database Schema into Logical Modules

```
packages/db/src/schema/
├── users.ts        (users, profiles)
├── projects.ts     (projects, api-keys, provider-keys)
├── threads.ts      (threads, messages, tool-calls)
├── oauth.ts        (oauth-states, oauth-connections)
└── index.ts        (re-export all)
```

**Benefit**: Improved readability, easier to locate schema definitions
**Effort**: 4-6 hours
**Breaking**: No, purely organizational

---

## Recommendations: Long-Term Vision (Architectural Evolution)

### 9. Establish Performance Budgets

- Set Next.js page size budgets (Core Web Vitals)
- Monitor API response times (P95 latency targets)
- Track bundle sizes for react-sdk (impact on users' apps)

**Effort**: 1 week of setup + ongoing monitoring

### 10. Implement E2E Testing Strategy

Recommend Playwright or Cypress for:

- User authentication flows
- Component generation and rendering
- Thread creation and message submission
- Dashboard CRUD operations

**Effort**: 2 weeks initial implementation, ~10% CI time overhead

### 11. Create Design System Documentation

Extend Showcase to include:

- Component API documentation auto-generated from Zod schemas
- Accessibility guidelines for each component
- Interaction patterns (form submission, async handling)
- Dark mode compatibility matrix

**Effort**: 1 month (ongoing)

### 12. Establish MCP Testing Framework

As MCP becomes more central to Tambo's value proposition:

- Create test utilities for MCP server integration
- Document MCP tool testing patterns
- Set up examples for common integrations (Linear, Slack, etc.)

**Effort**: 2 weeks

---

## Code Quality Summary Table

| Dimension                  | Rating | Evidence                                                   |
| -------------------------- | ------ | ---------------------------------------------------------- |
| **TypeScript Strictness**  | A+     | Zero type errors, strict config, no `any`                  |
| **Linting Discipline**     | A      | Full ESLint pass, shared config                            |
| **Testing Coverage**       | C+     | Strategic tests present, but gaps in API/web               |
| **Documentation**          | B+     | Excellent in framework packages, lacking in Cloud apps     |
| **Naming Conventions**     | A      | Well-defined, consistently followed                        |
| **Architecture Clarity**   | A-     | Clear domains, some provider complexity                    |
| **Security Posture**       | B+     | Proper env management, guards in place, no secrets visible |
| **Performance Monitoring** | C      | Sentry/Langfuse integrated, strategy not documented        |
| **Accessibility**          | B      | Radix UI used, patterns not formally documented            |
| **Maintainability**        | A-     | Good module structure, some areas could simplify           |

---

## Final Assessment

**Overall Grade: A- (Excellent)**

Tambo AI's codebase is mature, well-governed, and ready for production. The architectural decisions are sound, tooling is professional, and development practices are exemplary. The primary opportunities are:

1. **Documentation completeness** in Cloud platform (apps/api, apps/web)
2. **Testing expansion** to cover integration and e2e scenarios
3. **Architectural simplification** in provider nesting and guard consolidation

The team has built a strong foundation. The next phase should focus on deepening test coverage, formally documenting the Cloud platform architecture, and gradually reducing provider hierarchy complexity as the SDK evolves.

**Recommendation**: Use this audit as a basis for quarterly improvement goals. Priority order:

1. Cloud platform AGENTS.md (immediate)
2. Testing expansion (next quarter)
3. Architectural refinements (ongoing)

---

## How to Use This Audit

1. **Share with the team**: Use as a reference for architectural discussions
2. **Extract action items**: Create GitHub issues from recommendations section
3. **Prioritize**: Focus on immediate actions (high impact, low effort) first
4. **Revisit quarterly**: Re-run this audit process to track progress
