#!/usr/bin/env node
/**
 * Sync script for copying components from CLI registry to showcase
 *
 * This script reads config.json files from cli/src/registry/{component}/
 * and copies all specified files to showcase/src/components/tambo/
 * with banner comments and dependency validation.
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import chokidar from "chokidar";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Resolve paths relative to monorepo root
// The script is in .conductor/component-sync/scripts/, so go up one level to get to monorepo root
const MONOREPO_ROOT = path.resolve(__dirname, "..");
const CLI_REGISTRY_PATH = path.join(MONOREPO_ROOT, "cli/src/registry");
const SHOWCASE_SRC_PATH = path.join(MONOREPO_ROOT, "showcase/src");
const SHOWCASE_COMPONENTS_PATH = path.join(
  SHOWCASE_SRC_PATH,
  "components/tambo",
);
const SHOWCASE_LIB_PATH = path.join(SHOWCASE_SRC_PATH, "lib");
const SHOWCASE_PACKAGE_JSON = path.join(MONOREPO_ROOT, "showcase/package.json");
const CLI_REGISTRY_CSS = path.join(CLI_REGISTRY_PATH, "config/globals-v4.css");
const SHOWCASE_COMPONENTS_CSS = path.join(
  MONOREPO_ROOT,
  "showcase/src/app/components.css",
);

interface FileConfig {
  name?: string;
  content?: string;
  path?: string;
  type?: string;
}

interface ComponentConfig {
  name: string;
  description: string;
  componentName?: string;
  dependencies?: string[];
  devDependencies?: string[];
  requires?: string[];
  registryDependencies?: string[];
  files: FileConfig[];
  type?: string;
}

interface SyncResult {
  component: string;
  filesSync: number;
  errors: string[];
  missingDeps: string[];
}

/**
 * Generate banner comment for synced files
 */
function generateBanner(componentName: string): string {
  return `/**
 * THIS FILE IS AUTO-SYNCED FROM CLI REGISTRY
 *
 * Component: ${componentName}
 * Source: cli/src/registry/${componentName}/
 *
 * DO NOT EDIT THIS FILE DIRECTLY
 * Make changes in cli/src/registry/${componentName}/ and run sync script
 */

`;
}

/**
 * Read and parse component config.json
 */
function readComponentConfig(componentName: string): ComponentConfig | null {
  const configPath = path.join(CLI_REGISTRY_PATH, componentName, "config.json");

  try {
    if (!fs.existsSync(configPath)) {
      return null;
    }

    const configContent = fs.readFileSync(configPath, "utf-8");
    return JSON.parse(configContent) as ComponentConfig;
  } catch (error) {
    console.error(`Error reading config for ${componentName}:`, error);
    return null;
  }
}

/**
 * Get all component names from registry
 */
function getAllComponents(): string[] {
  try {
    if (!fs.existsSync(CLI_REGISTRY_PATH)) {
      throw new Error(`Registry path does not exist: ${CLI_REGISTRY_PATH}`);
    }

    return fs
      .readdirSync(CLI_REGISTRY_PATH)
      .filter((file) => {
        const fullPath = path.join(CLI_REGISTRY_PATH, file);
        return fs.statSync(fullPath).isDirectory() && file !== "config";
      })
      .filter((name) => {
        // Only include components with valid config.json
        const configPath = path.join(CLI_REGISTRY_PATH, name, "config.json");
        return fs.existsSync(configPath);
      });
  } catch (error) {
    console.error("Error reading registry:", error);
    return [];
  }
}

/**
 * Read showcase package.json and extract dependencies
 */
function getShowcaseDependencies(): Set<string> {
  try {
    const packageContent = fs.readFileSync(SHOWCASE_PACKAGE_JSON, "utf-8");
    const packageJson = JSON.parse(packageContent);

    const allDeps = new Set<string>();

    if (packageJson.dependencies) {
      Object.keys(packageJson.dependencies).forEach((dep) => allDeps.add(dep));
    }

    if (packageJson.devDependencies) {
      Object.keys(packageJson.devDependencies).forEach((dep) =>
        allDeps.add(dep),
      );
    }

    return allDeps;
  } catch (error) {
    console.error("Error reading showcase package.json:", error);
    return new Set();
  }
}

/**
 * Validate component dependencies against showcase package.json
 */
function validateDependencies(
  config: ComponentConfig,
  showcaseDeps: Set<string>,
): string[] {
  const missingDeps: string[] = [];

  // Check runtime dependencies
  if (config.dependencies && Array.isArray(config.dependencies)) {
    config.dependencies.forEach((dep) => {
      // Handle subpath exports (e.g., "@tambo-ai/react/mcp")
      // Extract the base package name
      const basePackage =
        dep.includes("/") && dep.startsWith("@")
          ? dep.split("/").slice(0, 2).join("/") // @scope/package
          : dep.split("/")[0]; // regular package

      if (!showcaseDeps.has(dep) && !showcaseDeps.has(basePackage)) {
        missingDeps.push(dep);
      }
    });
  }

  // Check dev dependencies
  if (config.devDependencies && Array.isArray(config.devDependencies)) {
    config.devDependencies.forEach((dep) => {
      // Handle subpath exports
      const basePackage =
        dep.includes("/") && dep.startsWith("@")
          ? dep.split("/").slice(0, 2).join("/")
          : dep.split("/")[0];

      if (!showcaseDeps.has(dep) && !showcaseDeps.has(basePackage)) {
        missingDeps.push(dep);
      }
    });
  }

  return missingDeps;
}

/**
 * Copy a single file with banner comment
 */
function copyFileWithBanner(
  sourcePath: string,
  targetPath: string,
  componentName: string,
): void {
  const sourceContent = fs.readFileSync(sourcePath, "utf-8");
  const banner = generateBanner(componentName);
  const finalContent = banner + sourceContent;

  // Ensure target directory exists
  const targetDir = path.dirname(targetPath);
  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
  }

  fs.writeFileSync(targetPath, finalContent, "utf-8");
}

/**
 * Sync a single component
 */
function resolveTargetPath(relativePath: string): string {
  const normalized = relativePath.replace(/^\.\//, "");

  if (normalized.startsWith("components/")) {
    return path.join(SHOWCASE_SRC_PATH, normalized);
  }

  if (normalized.startsWith("lib/")) {
    return path.join(SHOWCASE_LIB_PATH, normalized.slice("lib/".length));
  }

  return path.join(SHOWCASE_COMPONENTS_PATH, normalized);
}

function normalizeTargetRelativePath(fileConfig: FileConfig): string | null {
  if (fileConfig.path) {
    return fileConfig.path.trim();
  }

  if (fileConfig.name) {
    return fileConfig.name.trim();
  }

  return null;
}

function syncComponent(
  componentName: string,
  showcaseDeps: Set<string>,
): SyncResult {
  const result: SyncResult = {
    component: componentName,
    filesSync: 0,
    errors: [],
    missingDeps: [],
  };

  const config = readComponentConfig(componentName);

  if (!config) {
    result.errors.push("Could not read config.json");
    return result;
  }

  // Validate dependencies
  result.missingDeps = validateDependencies(config, showcaseDeps);

  // Copy each file
  config.files.forEach((fileConfig) => {
    try {
      const targetRelativePath = normalizeTargetRelativePath(fileConfig);
      if (!targetRelativePath) {
        result.errors.push(`Invalid file config: missing path or name/content`);
        return;
      }

      let sourcePath: string;

      if (fileConfig.path) {
        const registryPath = path.join(
          CLI_REGISTRY_PATH,
          componentName,
          path.basename(fileConfig.path),
        );
        if (fs.existsSync(registryPath)) {
          sourcePath = registryPath;
        } else {
          sourcePath = path.join(MONOREPO_ROOT, "cli/src", fileConfig.path);
        }
      } else if (fileConfig.content) {
        sourcePath = path.join(MONOREPO_ROOT, "cli", fileConfig.content);
      } else {
        result.errors.push(`Invalid file config: missing path or content`);
        return;
      }

      const targetPath = resolveTargetPath(targetRelativePath);

      if (!fs.existsSync(sourcePath)) {
        result.errors.push(`Source file not found: ${sourcePath}`);
        return;
      }

      copyFileWithBanner(sourcePath, targetPath, componentName);
      result.filesSync++;
    } catch (error) {
      result.errors.push(`Error copying file: ${error}`);
    }
  });

  return result;
}

/**
 * Sync CSS file from registry to showcase
 */
function syncComponentsCSS(): boolean {
  try {
    if (!fs.existsSync(CLI_REGISTRY_CSS)) {
      console.error(`CSS source not found: ${CLI_REGISTRY_CSS}`);
      return false;
    }

    const cssContent = fs.readFileSync(CLI_REGISTRY_CSS, "utf-8");
    const banner = `/**
 * THIS FILE IS AUTO-SYNCED FROM CLI REGISTRY
 *
 * Source: cli/src/registry/config/globals-v4.css
 *
 * DO NOT EDIT THIS FILE DIRECTLY
 * Make changes in cli/src/registry/config/globals-v4.css and run sync script
 */

`;
    const finalContent = banner + cssContent;

    fs.writeFileSync(SHOWCASE_COMPONENTS_CSS, finalContent, "utf-8");
    console.log("âœ“ CSS synced: components.css");
    return true;
  } catch (error) {
    console.error(`Error syncing CSS: ${error}`);
    return false;
  }
}

/**
 * Sync all components from registry to showcase
 */
function syncAllComponents(): void {
  console.log("Starting component sync...\n");
  console.log(`Registry: ${CLI_REGISTRY_PATH}`);
  console.log(`Component Target: ${SHOWCASE_COMPONENTS_PATH}`);
  console.log(`Lib Target: ${SHOWCASE_LIB_PATH}\n`);

  // Sync CSS first
  syncComponentsCSS();
  console.log();

  const components = getAllComponents();
  const showcaseDeps = getShowcaseDependencies();

  console.log(`Found ${components.length} components to sync\n`);

  const results: SyncResult[] = [];
  let totalFiles = 0;
  let totalErrors = 0;
  let totalMissingDeps = 0;

  components.forEach((component) => {
    const result = syncComponent(component, showcaseDeps);
    results.push(result);

    totalFiles += result.filesSync;
    totalErrors += result.errors.length;
    totalMissingDeps += result.missingDeps.length;

    // Print result for this component
    const status = result.errors.length > 0 ? "âš ï¸" : "âœ“";
    console.log(`${status} ${component}: ${result.filesSync} files synced`);

    if (result.errors.length > 0) {
      result.errors.forEach((error) => {
        console.log(`  ERROR: ${error}`);
      });
    }

    if (result.missingDeps.length > 0) {
      console.log(`  MISSING DEPS: ${result.missingDeps.join(", ")}`);
    }
  });

  // Print summary
  console.log("\n" + "=".repeat(50));
  console.log("SYNC SUMMARY");
  console.log("=".repeat(50));
  console.log(`Components synced: ${components.length}`);
  console.log(`Files synced: ${totalFiles}`);
  console.log(`Errors: ${totalErrors}`);
  console.log(`Missing dependencies: ${totalMissingDeps}`);

  if (totalMissingDeps > 0) {
    console.log("\nWARNING: Some components have missing dependencies!");
    console.log("Add these to showcase/package.json:");

    const allMissingDeps = new Set<string>();
    results.forEach((r) => r.missingDeps.forEach((d) => allMissingDeps.add(d)));
    allMissingDeps.forEach((dep) => console.log(`  - ${dep}`));
  }

  if (totalErrors > 0) {
    console.log("\nERROR: Some components failed to sync. See errors above.");
    process.exit(1);
  }

  console.log("\nâœ¨ Sync completed successfully!");
}

/**
 * Watch mode implementation
 */
function startWatchMode(): void {
  console.log("Starting watch mode...\n");
  console.log(`Watching: ${CLI_REGISTRY_PATH}`);
  console.log(`Component Target: ${SHOWCASE_COMPONENTS_PATH}`);
  console.log(`Lib Target: ${SHOWCASE_LIB_PATH}\n`);
  console.log("Press Ctrl+C to stop\n");

  // Perform initial sync
  syncAllComponents();

  // Watch for changes
  const watcher = chokidar.watch(
    [
      `${CLI_REGISTRY_PATH}/**/config.json`,
      `${CLI_REGISTRY_PATH}/**/*.tsx`,
      `${CLI_REGISTRY_PATH}/**/*.ts`,
      `${CLI_REGISTRY_PATH}/config/globals-v4.css`,
    ],
    {
      persistent: true,
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 100,
        pollInterval: 50,
      },
    },
  );

  watcher.on("change", (filePath) => {
    console.log(
      `\nðŸ“ File changed: ${path.relative(CLI_REGISTRY_PATH, filePath)}`,
    );

    // Check if it's the CSS file
    if (filePath === CLI_REGISTRY_CSS) {
      console.log("ðŸŽ¨ Syncing CSS...");
      syncComponentsCSS();
      return;
    }

    // Extract component name from path
    const relativePath = path.relative(CLI_REGISTRY_PATH, filePath);
    const componentName = relativePath.split(path.sep)[0];

    if (componentName && componentName !== "config") {
      console.log(`ðŸ”„ Syncing ${componentName}...`);
      const showcaseDeps = getShowcaseDependencies();
      const result = syncComponent(componentName, showcaseDeps);

      if (result.errors.length > 0) {
        console.log(`âš ï¸  Errors during sync:`);
        result.errors.forEach((error) => console.log(`   ${error}`));
      } else {
        console.log(`âœ“ ${componentName}: ${result.filesSync} files synced`);
      }

      if (result.missingDeps.length > 0) {
        console.log(`âš ï¸  Missing deps: ${result.missingDeps.join(", ")}`);
      }
    }
  });

  watcher.on("add", (filePath) => {
    console.log(
      `\nâž• File added: ${path.relative(CLI_REGISTRY_PATH, filePath)}`,
    );

    // Extract component name from path
    const relativePath = path.relative(CLI_REGISTRY_PATH, filePath);
    const componentName = relativePath.split(path.sep)[0];

    if (componentName && componentName !== "config") {
      console.log(`ðŸ”„ Syncing ${componentName}...`);
      const showcaseDeps = getShowcaseDependencies();
      const result = syncComponent(componentName, showcaseDeps);

      if (result.errors.length > 0) {
        console.log(`âš ï¸  Errors during sync:`);
        result.errors.forEach((error) => console.log(`   ${error}`));
      } else {
        console.log(`âœ“ ${componentName}: ${result.filesSync} files synced`);
      }

      if (result.missingDeps.length > 0) {
        console.log(`âš ï¸  Missing deps: ${result.missingDeps.join(", ")}`);
      }
    }
  });

  watcher.on("error", (error) => {
    console.error("Watcher error:", error);
  });
}

/**
 * Main entry point
 */
function main(): void {
  const args = process.argv.slice(2);
  const watchMode = args.includes("--watch") || args.includes("-w");

  if (watchMode) {
    startWatchMode();
  } else {
    syncAllComponents();
  }
}

// Run the script
main();
