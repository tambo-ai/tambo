import { env } from "@/lib/env";
import {
  createTRPCRouter,
  protectedProcedure,
  publicProcedure,
} from "@/server/api/trpc";
import { SessionSource } from "@tambo-ai-cloud/core";
import { schema } from "@tambo-ai-cloud/db";
import { TRPCError } from "@trpc/server";
import { and, eq, gt, isNull, sql } from "drizzle-orm";
import { z } from "zod";

// Constants
const CODE_EXPIRY_MINUTES = 15;
const POLL_INTERVAL_SECONDS = 5;
const SESSION_TOKEN_BYTES = 32;
const DEVICE_VERIFICATION_PATH = "/device";

/**
 * Get the base URL for constructing absolute verification URLs
 * Uses NEXT_PUBLIC_APP_URL or falls back to request headers
 */
function getVerificationBaseUrl(headers: Headers): string {
  // Prefer explicit env var
  if (env.NEXT_PUBLIC_APP_URL) {
    return env.NEXT_PUBLIC_APP_URL;
  }

  // Fall back to request headers
  const forwardedHost = headers.get("x-forwarded-host");
  const host = headers.get("host");
  const proto = headers.get("x-forwarded-proto") ?? "https";

  if (forwardedHost) {
    return `${proto}://${forwardedHost}`;
  }
  if (host) {
    return `${proto}://${host}`;
  }

  throw new Error(
    "Cannot determine verification base URL: NEXT_PUBLIC_APP_URL not set and no host header present",
  );
}

/**
 * Generate a random alphanumeric string for user codes
 * Uses uppercase letters and digits, excluding confusing characters (0, O, I, 1)
 * Charset is exactly 32 characters to avoid modulo bias (uses bitwise & 31)
 */
function generateUserCode(length: number = 8): string {
  // 32 chars: A-Z minus I,O (24 letters) + 2-9 (8 digits) = 32
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  const bytes = new Uint8Array(length);
  crypto.getRandomValues(bytes);
  return Array.from(bytes, (b) => chars[b & 31]).join("");
}

/**
 * Generate a cryptographically secure session token
 *
 * Uses 32 bytes (256 bits) of entropy encoded as base64url.
 * This is significantly more secure than UUIDs (which have ~122 bits of entropy)
 * and should be treated as a secret credential.
 *
 * SECURITY: Never log or display this token. It grants account access.
 */
function generateSessionToken(): string {
  const bytes = new Uint8Array(SESSION_TOKEN_BYTES);
  crypto.getRandomValues(bytes);
  // Base64url encoding (URL-safe, no padding)
  return btoa(String.fromCharCode(...bytes))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/, "");
}

/**
 * Device Authentication Router
 *
 * Implements OAuth 2.0 Device Authorization Grant (RFC 8628) flow for CLI authentication.
 *
 * Flow:
 * 1. CLI calls `initiate` to get device_code + user_code
 * 2. User visits /device page and enters user_code
 * 3. User calls `verify` to link the device code to their session
 * 4. CLI polls `poll` until verification completes, then receives session token
 */
export const deviceAuthRouter = createTRPCRouter({
  /**
   * Initiate device auth flow (called by CLI)
   *
   * Device code is generated by Postgres (gen_random_uuid).
   * User code is generated in app code for custom human-readable charset.
   * Returns absolute verification URLs per RFC 8628.
   */
  initiate: publicProcedure.mutation(async ({ ctx }) => {
    const userCode = generateUserCode(8);

    // Insert the device auth code (deviceCode, expiresAt, isUsed have Postgres defaults)
    const [inserted] = await ctx.db
      .insert(schema.deviceAuthCodes)
      .values({ userCode })
      .returning({ deviceCode: schema.deviceAuthCodes.deviceCode });

    // Format user code with dash for display (XXXX-XXXX)
    const formattedUserCode = `${userCode.slice(0, 4)}-${userCode.slice(4)}`;

    // Construct absolute URLs per RFC 8628
    const baseUrl = getVerificationBaseUrl(ctx.headers);
    const verificationUri = `${baseUrl}${DEVICE_VERIFICATION_PATH}`;

    // Use URL API for proper encoding
    const completeUrl = new URL(verificationUri);
    completeUrl.searchParams.set("user_code", userCode);
    const verificationUriComplete = completeUrl.toString();

    return {
      deviceCode: inserted.deviceCode,
      userCode: formattedUserCode,
      verificationUri,
      verificationUriComplete,
      expiresIn: CODE_EXPIRY_MINUTES * 60,
      interval: POLL_INTERVAL_SECONDS,
    };
  }),

  /**
   * Verify a device code (called by browser after user enters code)
   *
   * This is a protected procedure - user must be logged in.
   * Links the device code to the authenticated user and creates a CLI session.
   */
  verify: protectedProcedure
    .input(
      z.object({
        userCode: z
          .string()
          .min(1, "User code is required")
          .transform((val) => val.replace(/-/g, "").trim()),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const now = new Date();

      // Generate high-entropy session token (256 bits)
      // SECURITY: This token is a credential - never log it
      const sessionToken = generateSessionToken();

      // Create session first (required by FK constraint on device_auth_codes)
      // expiresAt defaults to 90 days from now (set in schema)
      await ctx.db.insert(schema.sessions).values({
        id: sessionToken,
        userId: ctx.user.id,
        source: SessionSource.CLI,
      });

      // Atomically claim the device code with conditional update
      // This prevents race conditions - only one request can successfully claim a code
      const updateResult = await ctx.db
        .update(schema.deviceAuthCodes)
        .set({
          userId: ctx.user.id,
          sessionId: sessionToken,
          isUsed: true,
        })
        .where(
          and(
            eq(schema.deviceAuthCodes.userCode, input.userCode),
            eq(schema.deviceAuthCodes.isUsed, false),
            gt(schema.deviceAuthCodes.expiresAt, now),
            isNull(schema.deviceAuthCodes.userId),
          ),
        )
        .returning({ id: schema.deviceAuthCodes.id });

      // If update succeeded (exactly 1 row), we're done
      if (updateResult.length === 1) {
        return {
          success: true,
          message: "Device authorized successfully",
        };
      }

      // Update failed - delete the orphaned session we just created
      await ctx.db
        .delete(schema.sessions)
        .where(eq(schema.sessions.id, sessionToken));

      // Update failed - determine why (for internal logging only)
      const [existingCode] = await ctx.db
        .select()
        .from(schema.deviceAuthCodes)
        .where(eq(schema.deviceAuthCodes.userCode, input.userCode))
        .limit(1);

      if (existingCode) {
        if (existingCode.isUsed) {
          throw new TRPCError({
            code: "UNAUTHORIZED",
            message: "CODE_ALREADY_USED",
          });
        }
        if (existingCode.expiresAt <= now) {
          throw new TRPCError({
            code: "UNAUTHORIZED",
            message: "CODE_EXPIRED",
          });
        }
      }

      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "INVALID_CODE",
      });
    }),

  /**
   * Poll for verification completion (called by CLI)
   *
   * Returns the session token once the user has verified the code.
   *
   * SECURITY: The sessionToken returned is a high-entropy credential (256 bits).
   * It grants full account access and must NEVER be logged server-side.
   *
   * Rate limiting: Enforces server-side poll interval to prevent abuse.
   */
  poll: publicProcedure
    .input(
      z.object({
        deviceCode: z.string().uuid("Invalid device code format"),
      }),
    )
    .query(async ({ ctx, input }) => {
      const now = new Date();
      // Allow 1 second buffer for network latency
      const minPollIntervalMs = (POLL_INTERVAL_SECONDS - 1) * 1000;

      // Find the device auth code
      const [deviceAuthCode] = await ctx.db
        .select()
        .from(schema.deviceAuthCodes)
        .where(eq(schema.deviceAuthCodes.deviceCode, input.deviceCode))
        .limit(1);

      if (!deviceAuthCode) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "INVALID_DEVICE_CODE",
        });
      }

      // Server-side rate limiting: check if polled too recently
      if (deviceAuthCode.lastPolledAt) {
        const timeSinceLastPoll =
          now.getTime() - deviceAuthCode.lastPolledAt.getTime();
        if (timeSinceLastPoll < minPollIntervalMs) {
          throw new TRPCError({
            code: "TOO_MANY_REQUESTS",
            message: "SLOW_DOWN",
          });
        }
      }

      // Update last poll timestamp (fire-and-forget, don't block response)
      void ctx.db
        .update(schema.deviceAuthCodes)
        .set({ lastPolledAt: now })
        .where(eq(schema.deviceAuthCodes.deviceCode, input.deviceCode))
        .execute();

      // Check if expired
      if (deviceAuthCode.expiresAt <= now) {
        return {
          status: "expired" as const,
        };
      }

      // Check if verified
      if (deviceAuthCode.isUsed && deviceAuthCode.sessionId) {
        // Get session expiry for the response
        const [session] = await ctx.db
          .select({
            expiresAt: schema.sessions.expiresAt,
          })
          .from(schema.sessions)
          .where(eq(schema.sessions.id, deviceAuthCode.sessionId))
          .limit(1);

        if (!session) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Session not found for completed device auth code",
          });
        }

        return {
          status: "complete" as const,
          sessionToken: deviceAuthCode.sessionId,
          expiresAt: session.expiresAt.toISOString(),
        };
      }

      // Still pending
      return {
        status: "pending" as const,
      };
    }),

  /**
   * List active CLI sessions (called by browser or CLI)
   *
   * Returns all non-expired CLI sessions for the authenticated user.
   * Only returns sessions with source='cli' (browser sessions are audit-only).
   *
   * SECURITY NOTE: Session IDs are returned here for revocation purposes.
   * This is acceptable because:
   * - User can only see their own sessions (authenticated)
   * - Transmitted over HTTPS
   * - Required for revoke functionality
   * However, these IDs should NEVER be logged server-side.
   */
  listSessions: protectedProcedure.query(async ({ ctx }) => {
    const userSessions = await ctx.db
      .select({
        id: schema.sessions.id,
        createdAt: schema.sessions.createdAt,
        updatedAt: schema.sessions.updatedAt,
        expiresAt: schema.sessions.expiresAt,
      })
      .from(schema.sessions)
      .where(
        and(
          eq(schema.sessions.userId, ctx.user.id),
          eq(schema.sessions.source, SessionSource.CLI),
          gt(schema.sessions.expiresAt, sql`now()`),
        ),
      )
      .orderBy(schema.sessions.createdAt);

    return userSessions;
  }),

  /**
   * Revoke a CLI session (called by browser or CLI)
   *
   * Deletes the session, which will invalidate the CLI's access.
   * Only CLI sessions can be revoked (browser sessions are audit-only).
   */
  revokeSession: protectedProcedure
    .input(
      z.object({
        sessionId: z.string(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      // Verify the session belongs to the user and is a CLI session
      const [session] = await ctx.db
        .select()
        .from(schema.sessions)
        .where(
          and(
            eq(schema.sessions.id, input.sessionId),
            eq(schema.sessions.userId, ctx.user.id),
            eq(schema.sessions.source, SessionSource.CLI),
          ),
        )
        .limit(1);

      if (!session) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Session not found or not authorized",
        });
      }

      // Delete the session
      await ctx.db
        .delete(schema.sessions)
        .where(eq(schema.sessions.id, input.sessionId));

      return {
        success: true,
        message: "Session revoked",
      };
    }),

  /**
   * Revoke all CLI sessions for the authenticated user
   *
   * Atomically deletes all CLI sessions in a single operation.
   * Only CLI sessions are revoked (browser sessions are audit-only).
   * More efficient than revoking sessions one by one.
   */
  revokeAllSessions: protectedProcedure.mutation(async ({ ctx }) => {
    const result = await ctx.db
      .delete(schema.sessions)
      .where(
        and(
          eq(schema.sessions.userId, ctx.user.id),
          eq(schema.sessions.source, SessionSource.CLI),
        ),
      )
      .returning({ id: schema.sessions.id });

    return {
      success: true,
      revokedCount: result.length,
      message: `Revoked ${result.length} session(s)`,
    };
  }),
});
