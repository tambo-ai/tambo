---
phase: 03-plan-generation
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - cli/src/utils/plan-generation/json-extraction.ts
  - cli/src/utils/plan-generation/json-extraction.test.ts
  - cli/src/utils/plan-generation/index.ts
  - cli/src/utils/plan-generation/index.test.ts
autonomous: true

must_haves:
  truths:
    - "generatePlan() sends ProjectAnalysis to Tambo API and returns validated InstallationPlan"
    - "JSON extraction handles markdown code blocks, raw JSON, and mixed text reliably"
    - "Invalid model output produces clear error messages, not silent failures"
  artifacts:
    - path: "cli/src/utils/plan-generation/json-extraction.ts"
      provides: "Robust JSON extraction from LLM text responses"
      exports: ["extractJsonFromResponse"]
    - path: "cli/src/utils/plan-generation/index.ts"
      provides: "Main generatePlan orchestrator"
      exports: ["generatePlan"]
  key_links:
    - from: "cli/src/utils/plan-generation/index.ts"
      to: "packages/client-core/src/run.ts"
      via: "executeRun() for streaming API interaction"
      pattern: "executeRun"
    - from: "cli/src/utils/plan-generation/index.ts"
      to: "cli/src/utils/plan-generation/prompt-builder.ts"
      via: "buildPlanPrompt() to construct the prompt"
      pattern: "buildPlanPrompt"
    - from: "cli/src/utils/plan-generation/index.ts"
      to: "cli/src/utils/plan-generation/schemas.ts"
      via: "installationPlanSchema.parse() to validate output"
      pattern: "installationPlanSchema\\.parse"
---

<objective>
Build the plan generation orchestrator that sends codebase analysis to the Tambo API via client-core, extracts JSON from the model response, validates it against the Zod schema, and returns a typed InstallationPlan.

Purpose: Connect Phase 2 analysis output to LLM intelligence, producing structured recommendations.
Output: json-extraction.ts (with tests), index.ts orchestrator (with tests)
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-plan-generation/03-RESEARCH.md
@.planning/phases/03-plan-generation/03-01-SUMMARY.md
@packages/client-core/src/run.ts
@packages/client-core/src/client.ts
@packages/client-core/src/index.ts
@cli/src/utils/plan-generation/types.ts
@cli/src/utils/plan-generation/schemas.ts
@cli/src/utils/plan-generation/prompt-builder.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: JSON extraction utility with tests</name>
  <files>
    cli/src/utils/plan-generation/json-extraction.ts
    cli/src/utils/plan-generation/json-extraction.test.ts
  </files>
  <action>
Create `cli/src/utils/plan-generation/json-extraction.ts`:
- Export `extractJsonFromResponse(text: string): unknown`
- Try extraction in this priority order:
  1. Markdown JSON code block: match ```json\n...\n``` or ```\n...\n```
  2. JSON object in text: find outermost `{...}` (greedy match)
  3. JSON array in text: find outermost `[...]` (greedy match)
  4. Entire text as JSON: `JSON.parse(text.trim())`
- Each step wraps `JSON.parse` in try/catch and falls through to next
- If all fail, throw `Error("Failed to extract JSON from response: {first 200 chars of text}")` — include truncated text for debugging
- Do NOT use regex with global flag (per AGENTS.md). Use non-global regex for matching.

Create `cli/src/utils/plan-generation/json-extraction.test.ts` (TDD):

- Extracts from ```json code block
- Extracts from ``` code block (no language tag)
- Extracts from raw JSON object (no wrapping text)
- Extracts from JSON embedded in explanatory text ("Here is the plan:\n{...}\nLet me know...")
- Extracts from raw JSON array
- Handles nested objects correctly
- Throws with descriptive error for non-JSON text
- Throws with descriptive error for empty string
- Handles trailing commas gracefully (JSON.parse will reject — that's fine, test the error path)
  </action>
  <verify>
  Run: `npm test -- --testPathPattern="plan-generation/json-extraction" --no-coverage` from cli/
  All tests pass.
  </verify>
  <done>
  extractJsonFromResponse reliably extracts JSON from various LLM output formats and provides clear errors on failure.
  </done>
  </task>

<task type="auto">
  <name>Task 2: generatePlan orchestrator with tests</name>
  <files>
    cli/src/utils/plan-generation/index.ts
    cli/src/utils/plan-generation/index.test.ts
  </files>
  <action>
Create `cli/src/utils/plan-generation/index.ts`:

Export `generatePlan(options: GeneratePlanOptions): Promise<InstallationPlan>` where:

```typescript
interface GeneratePlanOptions {
  projectAnalysis: ProjectAnalysis;
  apiKey: string;
  baseUrl?: string;
  onProgress?: (chunk: string) => void;
}
```

Implementation:

1. `createTamboClient({ apiKey, baseUrl })` from client-core
2. `client.threads.create({ title: "Tambo Magic Init - Plan Generation" })`
3. `buildPlanPrompt(projectAnalysis)` to construct prompt
4. `executeRun(client, threadId, prompt, { onEvent })` — in onEvent, when event type is "TEXT_MESSAGE_CONTENT", call `onProgress?.(delta)` with the text delta
5. `extractJsonFromResponse(responseText)` to get raw JSON
6. `installationPlanSchema.parse(json)` to validate — if ZodError, throw `Error("Model returned invalid plan: {zodError.message}")` with the Zod error details
7. Return validated plan

Also re-export types and key functions:

- Re-export `InstallationPlan` and recommendation types from types.ts
- Re-export `buildPlanPrompt` from prompt-builder.ts
- Re-export `installationPlanSchema` from schemas.ts

Create `cli/src/utils/plan-generation/index.test.ts`:

- Mock `@tambo-ai/client-core` module (createTamboClient, executeRun)
- Test: successful plan generation — mock executeRun to return valid JSON string, verify generatePlan returns parsed InstallationPlan
- Test: calls createTamboClient with provided apiKey and baseUrl
- Test: creates thread with expected title
- Test: passes buildPlanPrompt output as message to executeRun
- Test: calls onProgress callback with text deltas from streaming events
- Test: throws descriptive error when model returns invalid JSON
- Test: throws descriptive error when model returns valid JSON that fails Zod validation (e.g., missing required field)
- Test: re-exports are accessible (import { InstallationPlan, buildPlanPrompt, installationPlanSchema } from index)

Mock strategy: Mock createTamboClient to return object with `threads.create()` returning `{ id: "test-thread" }` and `sdk` property. Mock executeRun at module level. Do NOT mock internal functions (prompt-builder, schemas) — let them run for integration coverage.
</action>
<verify>
Run: `npm test -- --testPathPattern="plan-generation/index" --no-coverage` from cli/
Run: `npm test -- --testPathPattern="plan-generation" --no-coverage` from cli/ (all plan-generation tests)
Run: `npm run check-types` from root
Run: `npm run lint` from cli/
All pass.
</verify>
<done>
generatePlan() accepts ProjectAnalysis + API key, calls Tambo API via client-core, validates response, and returns typed InstallationPlan. All error paths produce clear messages.
</done>
</task>

</tasks>

<verification>
```bash
cd cli && npm test -- --testPathPattern="plan-generation" --no-coverage
cd .. && npm run check-types
cd cli && npm run lint
npm test  # Full test suite, no regressions
```
All tests pass, types compile, lint clean, no regressions.
</verification>

<success_criteria>

- generatePlan() end-to-end: ProjectAnalysis in, InstallationPlan out
- JSON extraction handles markdown blocks, raw JSON, mixed text
- Invalid model output surfaces clear errors (not silent failures)
- onProgress callback receives streaming text deltas
- All plan-generation module tests pass
- Full CLI test suite has no regressions
  </success_criteria>

<output>
After completion, create `.planning/phases/03-plan-generation/03-02-SUMMARY.md`
</output>
