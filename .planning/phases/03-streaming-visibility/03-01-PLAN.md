---
phase: 03-streaming-visibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - react-sdk/src/devtools/devtools-protocol.ts
  - react-sdk/src/devtools/devtools-bridge.ts
  - react-sdk/src/devtools/tambo-dev-tools.tsx
  - react-sdk/src/devtools/use-stream-state-for-devtools.ts
  - apps/web/devtools-server/types.ts
  - apps/web/devtools-server/connection-manager.ts
  - apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts
autonomous: true

must_haves:
  truths:
    - "SDK emits individual AG-UI events over WebSocket as they occur during streaming"
    - "Devtools server forwards stream_event messages to all connected dashboard clients"
    - "Dashboard hook receives and exposes stream events per session"
  artifacts:
    - path: "react-sdk/src/devtools/devtools-protocol.ts"
      provides: "DevToolsStreamEvent and SerializedAGUIEvent types"
      contains: "stream_event"
    - path: "react-sdk/src/devtools/devtools-bridge.ts"
      provides: "emitEvent method with seq counter"
      contains: "emitEvent"
    - path: "apps/web/devtools-server/types.ts"
      provides: "StreamEventMessage and StreamEventUpdateMessage server types"
      contains: "stream_event"
    - path: "apps/web/devtools-server/connection-manager.ts"
      provides: "stream_event handling in handleSdkMessage"
      contains: "stream_event"
  key_links:
    - from: "react-sdk/src/devtools/tambo-dev-tools.tsx"
      to: "devtools-bridge.ts emitEvent"
      via: "onRawEvent callback from stream context"
      pattern: "bridge.*emitEvent"
    - from: "apps/web/devtools-server/connection-manager.ts"
      to: "dashboard clients"
      via: "broadcastToDashboard with stream_event_update"
      pattern: "stream_event_update"
    - from: "apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts"
      to: "dashboard state"
      via: "handleMessage case for stream_event_update"
      pattern: "stream_event_update"
---

<objective>
Extend the devtools wire protocol to support individual AG-UI event forwarding, add event emission to the SDK bridge, and wire the full path from SDK -> server -> dashboard hook.

Purpose: The existing snapshot-based protocol only sends debounced state. Phase 3 requires individual events forwarded in real-time to power the timeline, component streaming, and tool call views.
Output: Extended protocol types, bridge with emitEvent(), server forwarding, dashboard hook exposing events.
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-streaming-visibility/03-RESEARCH.md

@react-sdk/src/devtools/devtools-protocol.ts
@react-sdk/src/devtools/devtools-bridge.ts
@react-sdk/src/devtools/tambo-dev-tools.tsx
@react-sdk/src/devtools/use-stream-state-for-devtools.ts
@apps/web/devtools-server/types.ts
@apps/web/devtools-server/connection-manager.ts
@apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts
@react-sdk/src/v1/hooks/use-tambo-v1-send-message.ts
@react-sdk/src/v1/types/event.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend wire protocol and SDK bridge with stream_event support</name>
  <files>
    react-sdk/src/devtools/devtools-protocol.ts
    react-sdk/src/devtools/devtools-bridge.ts
    react-sdk/src/devtools/tambo-dev-tools.tsx
    react-sdk/src/devtools/use-stream-state-for-devtools.ts
  </files>
  <action>
    1. In `devtools-protocol.ts`, add:
       - `SerializedAGUIEvent` interface: `{ type: string; timestamp?: number; [key: string]: unknown }`
       - `DevToolsStreamEvent` interface: `{ type: "stream_event"; sessionId: string; timestamp: number; threadId: string; event: SerializedAGUIEvent; seq: number }`
       - Add `DevToolsStreamEvent` to the `DevToolsMessage` union type

    2. In `devtools-bridge.ts`, add:
       - Private `nextSeq = 0` counter field on `DevToolsBridge`
       - Public `emitEvent(event: unknown, threadId: string): void` method that:
         - Returns early if `!this.connected || !this.ws`
         - Serializes the event via `JSON.parse(JSON.stringify(event))` (lightweight, events are small plain objects)
         - Sends a `DevToolsStreamEvent` message with incrementing seq
       - Reset `nextSeq = 0` in the `connect()` method's open handler (after handshake)

    3. In `tambo-dev-tools.tsx`, add event forwarding:
       - The stream state context (from `useStreamStateForDevtools`) needs to expose raw events. Check if the stream context provider in `react-sdk/src/v1/` has an event callback mechanism. If not, add an `onRawEvent` callback pattern:
         - In the stream dispatch/provider code (likely `use-tambo-v1-send-message.ts` or the stream provider), add an optional `onRawEvent?: (event: unknown, threadId: string) => void` to the context value
         - Export this from the devtools-accessible context (similar to how StreamStateContext is exported @internal)
       - In `TamboDevTools`, subscribe to raw events via this callback and call `bridge.emitEvent(event, threadId)` using a ref-based pattern (same as existing `onRequestSnapshot` pattern to avoid stale closures)
       - Store the callback in a ref, update it on each render, and register/clean up the subscription in the bridge useEffect

    Important: The event capture must NOT modify the existing event dispatch flow. It is a read-only tap. Events should flow to devtools in parallel with normal dispatch, not instead of it. Follow the pattern from Phase 2 research: add the callback at the dispatch site where `dispatch({ type: "EVENT", event, threadId })` happens in `use-tambo-v1-send-message.ts` (around line 621).

  </action>
  <verify>
    - `npm run check-types` passes for react-sdk
    - `npm run lint` passes for react-sdk
    - `npm run test` passes for react-sdk
    - Verify `DevToolsStreamEvent` is in the `DevToolsMessage` union: `grep "DevToolsStreamEvent" react-sdk/src/devtools/devtools-protocol.ts`
    - Verify `emitEvent` method exists: `grep "emitEvent" react-sdk/src/devtools/devtools-bridge.ts`
  </verify>
  <done>SDK bridge can emit individual stream events over WebSocket with monotonic sequence numbers. TamboDevTools taps into raw events from the stream provider and forwards them to the bridge.</done>
</task>

<task type="auto">
  <name>Task 2: Extend server and dashboard hook to forward and receive stream events</name>
  <files>
    apps/web/devtools-server/types.ts
    apps/web/devtools-server/connection-manager.ts
    apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts
  </files>
  <action>
    1. In `apps/web/devtools-server/types.ts`, add:
       - `StreamEventMessage` interface mirroring SDK's `DevToolsStreamEvent`: `{ type: "stream_event"; sessionId: string; timestamp: number; threadId: string; event: { type: string; [key: string]: unknown }; seq: number }`
       - Add `StreamEventMessage` to the `SdkMessage` union
       - `StreamEventUpdateMessage` for server->dashboard: `{ type: "stream_event_update"; sessionId: string; event: StreamEventMessage }`
       - Add `StreamEventUpdateMessage` to the `ServerToDashboardMessage` union

    2. In `connection-manager.ts`, add a `stream_event` case to `handleSdkMessage`:
       - Broadcast to dashboard as `{ type: "stream_event_update", sessionId, event: message }` (just forward the whole message, no transformation needed)

    3. In `use-devtools-connection.ts`:
       - Add a `streamEvents` state: `Map<string, Array<StreamEventFromServer>>` keyed by sessionId, where `StreamEventFromServer` has `{ seq, timestamp, threadId, eventType: string, payload: Record<string, unknown> }`
       - In `handleMessage`, add a `stream_event_update` case that appends to the session's event array (cap at 5000 per session, drop oldest)
       - Export `streamEvents` and the current session's events from the hook return value
       - Add a `clearStreamEvents` function that empties events for a session (for the "clear timeline" feature)
       - On `client_disconnected`, also clean up that session's `streamEvents`

    Note: The full ring buffer will be in Plan 02. For this task, use a simple capped array (`if (arr.length >= 5000) arr.shift()`) since the dashboard hook just needs to store and expose events. Plan 02 will add the proper ring buffer + RAF batching on the UI side.

  </action>
  <verify>
    - `npm run check-types` passes for apps/web
    - `npm run lint` passes for apps/web
    - `grep "stream_event" apps/web/devtools-server/types.ts` shows the new types
    - `grep "stream_event_update" apps/web/devtools-server/connection-manager.ts` shows forwarding
    - `grep "streamEvents" apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts` shows the new state
  </verify>
  <done>Server forwards stream_event messages from SDK to dashboard. Dashboard hook stores events per session with a 5000 cap and exposes them for UI consumption.</done>
</task>

</tasks>

<verification>
- `npm run check-types` passes across workspace
- `npm run lint` passes across workspace
- `npm test` passes across workspace
- Wire protocol has `stream_event` in SDK, server, and dashboard types
- Bridge has `emitEvent` method
- Connection manager forwards events
- Dashboard hook stores and exposes events
</verification>

<success_criteria>
The full event pipeline (SDK capture -> bridge send -> server forward -> dashboard receive) is wired and type-safe. Events are stored per-session on the dashboard with a 5000 cap. No UI is rendered yet (that's Plans 02 and 03).
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming-visibility/03-01-SUMMARY.md`
</output>
