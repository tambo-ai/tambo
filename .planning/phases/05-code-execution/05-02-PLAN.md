---
phase: 05-code-execution
plan: 02
type: tdd
wave: 2
depends_on: ["05-01"]
cross_phase_dependencies:
  - phase: "04-user-confirmation"
    reason: "generateContentForRecommendation() from cli/src/utils/user-confirmation/content-generator.ts produces file content for all recommendation types (provider, components, tools, chat widget, interactables). Phase 4 must be complete before this plan executes."
files_modified:
  - cli/src/utils/code-execution/verification.ts
  - cli/src/utils/code-execution/verification.test.ts
  - cli/src/utils/code-execution/error-recovery.ts
  - cli/src/utils/code-execution/error-recovery.test.ts
  - cli/src/utils/code-execution/index.ts
  - cli/src/utils/code-execution/index.test.ts
autonomous: true

must_haves:
  truths:
    # Verification & error handling (user-observable)
    - "After execution completes, all written files exist on disk, are non-empty, and have valid syntax"
    - "When an operation fails, the user sees an actionable error message naming the failed phase and specific fix steps"
    - "No partial file changes remain on disk after an execution failure — all modified files are restored to pre-execution state"
    # Execution ordering (user-observable)
    - "All file changes are applied before dependency installation runs, and verification runs after both complete"
    - "On success, user sees a summary listing files created, files modified, and dependencies installed"
    # EXEC-03 through EXEC-07: content outcomes (generated by Phase 4's content-generator, written by this plan's orchestrator)
    - "TamboProvider is added to the root layout file (EXEC-03) — content produced by generateContentForRecommendation()"
    - "Selected components are registered with Tambo in the provider setup (EXEC-04) — content produced by generateContentForRecommendation()"
    - "Tool definitions are generated and written to new files (EXEC-05) — content produced by generateContentForRecommendation()"
    - "A working chat widget file is created or modified (EXEC-06) — content produced by generateContentForRecommendation()"
    - "Interactable integration code is added to existing component files (EXEC-07) — content produced by generateContentForRecommendation()"
    # EXEC-01 clarification
    # Note: EXEC-01 references "tool calls" from Phase 3's decision that the model handles code changes via tool calls.
    # Phase 5 directly applies the confirmed plan by writing files — it does not re-invoke model tool calls.
  artifacts:
    - path: "cli/src/utils/code-execution/verification.ts"
      provides: "verifyExecution function that checks file existence, readability, non-emptiness, basic syntax"
      exports: ["verifyExecution"]
    - path: "cli/src/utils/code-execution/error-recovery.ts"
      provides: "formatExecutionError, categorizeExecutionError for actionable error display"
      exports: ["formatExecutionError", "categorizeExecutionError"]
    - path: "cli/src/utils/code-execution/index.ts"
      provides: "executeCodeChanges orchestrator and re-exports"
      exports: ["executeCodeChanges"]
  key_links:
    - from: "cli/src/utils/code-execution/index.ts"
      to: "cli/src/utils/code-execution/file-operations.ts"
      via: "executeFileOperations, createBackup, restoreBackups, cleanupBackups"
      pattern: "import.*file-operations"
    - from: "cli/src/utils/code-execution/index.ts"
      to: "cli/src/utils/code-execution/dependency-installer.ts"
      via: "installDependencies, collectDependencies"
      pattern: "import.*dependency-installer"
    - from: "cli/src/utils/code-execution/index.ts"
      to: "cli/src/utils/code-execution/verification.ts"
      via: "verifyExecution"
      pattern: "import.*verification"
    - from: "cli/src/utils/code-execution/index.ts"
      to: "cli/src/utils/user-confirmation/types.ts"
      via: "ConfirmationResult input type"
      pattern: "ConfirmationResult"
---

<objective>
Build the verification checks, error formatting, and execution orchestrator that composes all Phase 5 modules into the complete flow: backup -> write files -> install deps -> verify -> report.

Purpose: This is the entry point Phase 5 consumers call. It takes a ConfirmationResult and produces an ExecutionResult.
Output: Tested verification module, tested error formatting, tested orchestrator with full flow.
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-code-execution/05-RESEARCH.md
@.planning/phases/05-code-execution/05-01-SUMMARY.md
@cli/src/utils/code-execution/types.ts
@cli/src/utils/code-execution/file-operations.ts
@cli/src/utils/code-execution/dependency-installer.ts
@cli/src/utils/user-confirmation/types.ts
@cli/src/utils/user-confirmation/content-generator.ts
@cli/src/utils/plan-generation/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verification and error formatting with TDD</name>
  <files>
    cli/src/utils/code-execution/verification.ts
    cli/src/utils/code-execution/verification.test.ts
    cli/src/utils/code-execution/error-recovery.ts
    cli/src/utils/code-execution/error-recovery.test.ts
  </files>
  <action>
Follow TDD: write failing tests FIRST, then implement.

**verification.ts — `verifyExecution(operations: FileOperation[])`:**

For each operation:

1. Check file exists (fs.access F_OK) — if not: push VerificationError "File was not created", suggest "Check file write permissions and disk space"
2. Check file readable (fs.access R_OK) — if not: push error "File exists but is not readable", suggest "Check file permissions"
3. Read content — if empty: push error "File is empty", suggest "Content generation may have failed"
4. For .ts/.tsx files: check balanced braces (count `{` vs `}`) — if unbalanced: push warning with suggestion "Check file syntax with: npx tsc --noEmit"
5. For .tsx files: check for import statement — if missing: push warning "React component missing imports"
6. Check for export statement — if missing: push warning "File has no exports"

Returns `VerificationError[]`.

Tests (use real temp files):

- Returns empty array for valid files
- Detects missing file
- Detects empty file
- Detects unbalanced braces in .ts file
- Detects missing imports in .tsx file
- Detects missing exports
- Skips syntax checks for non-TS files (e.g., .json, .css)

**error-recovery.ts:**

`categorizeExecutionError(error: Error, filePath?: string)`:

- Check `(error as NodeJS.ErrnoException).code`
- EACCES → phase: "file-write", suggestions about permissions
- ENOSPC → phase: "file-write", suggestions about disk space
- ENOENT → phase: "file-write", suggestions about parent directory
- Message contains "dependency" or "install" → phase: "dependency-install"
- Default → phase: "file-write" with generic suggestions
- Returns ExecutionError

`formatExecutionError(error: ExecutionError)`:

- Use chalk.red for header: "Execution failed during {phase}"
- chalk.yellow for file path and cause
- chalk.blue for numbered suggestions
- Returns formatted string

Tests (mock chalk or test string content):

- Categorizes EACCES as permission error with chmod suggestion
- Categorizes ENOSPC as disk space error
- Categorizes ENOENT as missing directory error
- Categorizes dependency errors by message
- Formats error with phase, cause, and numbered suggestions
  </action>
  <verify>
  Run `npm test -- --testPathPatterns='code-execution/(verification|error-recovery)' -w cli` — all tests pass.
  Run `npm run check-types -w cli` — no type errors.
  </verify>
  <done>
  Verification detects missing/empty/malformed files with actionable suggestions. Error formatting produces clear, styled terminal output with specific fix guidance. All tests pass.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Execution orchestrator with TDD</name>
  <files>
    cli/src/utils/code-execution/index.ts
    cli/src/utils/code-execution/index.test.ts
  </files>
  <action>
Follow TDD: write failing tests FIRST, then implement.

**index.ts — `executeCodeChanges(confirmation: ConfirmationResult, options?: { yes?: boolean })`:**

This is the main entry point for Phase 5. It takes the output of `confirmPlan()` and executes the approved changes.

Flow:

1. Guard: if `!confirmation.approved`, throw Error "Cannot execute: plan was not approved"
2. Create ora spinner
3. Create BackupManifest with current timestamp
4. **Identify files to modify** — extract file paths from the filtered plan:
   - Provider setup: `plan.providerSetup.filePath` (modify existing)
   - Components: each `componentRecommendation.filePath` (modify existing)
   - Tools: each `toolRecommendation.filePath` (create new — tool definition file)
   - Interactables: each `interactableRecommendation.filePath` (modify existing)
   - Chat widget: `plan.chatWidgetSetup.filePath` (modify existing or create new)
5. **Build FileOperation array** — for each item in `confirmation.selectedItems`:
   - Map item ID to plan data (provider-setup → providerSetup, component-N → componentRecommendations[N], etc.)
   - Read existing file content with `fs.readFile` (empty string for ENOENT)
   - Generate new content via `generateContentForRecommendation()` from `../user-confirmation/content-generator.js`
   - Create FileOperation: `{ filePath, content: newContent, isNew: existingContent === "" }`
6. **Backup** existing files (only those with isNew: false)
7. **Execute file writes** via `executeFileOperations(operations)` from `./file-operations.js`
8. **Install dependencies** via `installDependencies(collectDependencies(plan, selectedItems), options)` from `./dependency-installer.js`
9. **Verify** via `verifyExecution(operations)` from `./verification.js`
10. If verification has errors: spinner.warn, display warnings, but still mark success: true (warnings not blockers)
11. If no errors: spinner.succeed
12. Clean up backups on success
13. Display summary: files created count, files modified count, deps installed count
14. Return ExecutionResult

**Error handling (try/catch around steps 6-9):**

- On error: spinner.fail, restore backups, format error via categorizeExecutionError + formatExecutionError, re-throw

**Re-exports from index.ts:**

- Export `executeCodeChanges`
- Re-export types from `./types.js`
- Re-export `verifyExecution` from `./verification.js`
- Re-export `formatExecutionError`, `categorizeExecutionError` from `./error-recovery.js`
- Re-export `writeFileAtomic`, `installDependencies`, `collectDependencies` (for direct use if needed)

**Tests (mock all dependencies):**

- Mock file-operations (writeFileAtomic, createBackup, restoreBackups, cleanupBackups, executeFileOperations)
- Mock dependency-installer (installDependencies, collectDependencies)
- Mock verification (verifyExecution)
- Mock content-generator (generateContentForRecommendation)
- Mock ora to return stub spinner
- Mock fs.readFile for existing file content

Test cases:

- Throws when confirmation.approved is false
- Executes full flow: backup → write → install → verify → cleanup → returns success
- Calls restoreBackups when file operations throw
- Calls restoreBackups when dependency installation throws
- Returns success: true with verification warnings (non-blocking)
- Correctly builds FileOperation array from plan items
- Correctly identifies new vs modified files
- Re-exports all public API
  </action>
  <verify>
  Run `npm test -- --testPathPatterns='code-execution/index' -w cli` — all tests pass.
  Run `npm test -- --testPathPatterns='code-execution' -w cli` — ALL code-execution tests pass.
  Run `npm run check-types -w cli` — no type errors.
  Run `npm run lint -w cli` — no lint errors.
  </verify>
  <done>
  executeCodeChanges orchestrates the full execution flow. On success, files are written and deps installed. On failure, changes are rolled back and actionable error displayed. All tests pass across the entire code-execution module.
  </done>
  </task>

</tasks>

<verification>
```bash
npm test -- --testPathPatterns='code-execution' -w cli
npm run check-types -w cli
npm run lint -w cli
npm test -w cli
```
All code-execution tests pass. No type errors. No lint errors. Existing tests still pass.
</verification>

<success_criteria>

- Verification checks file existence, readability, content, and basic syntax
- Error formatting provides phase-specific suggestions (permissions, disk space, missing dirs)
- Orchestrator composes backup → write → install → verify → report in correct order
- Rollback restores files on any error during execution
- Summary displays files created, modified, and dependencies installed
- All module tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/05-code-execution/05-02-SUMMARY.md`
</output>
