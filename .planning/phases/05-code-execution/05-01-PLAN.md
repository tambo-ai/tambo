---
phase: 05-code-execution
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - cli/src/utils/code-execution/types.ts
  - cli/src/utils/code-execution/file-operations.ts
  - cli/src/utils/code-execution/file-operations.test.ts
  - cli/src/utils/code-execution/dependency-installer.ts
  - cli/src/utils/code-execution/dependency-installer.test.ts
autonomous: true

must_haves:
  truths:
    - "Files are written atomically using temp+rename pattern so partial writes never corrupt"
    - "Existing files are backed up before modification and restored on failure"
    - "Dependencies are installed using the detected package manager (npm/pnpm/yarn)"
    - "New files are created in the correct directories, creating parent dirs as needed"
  artifacts:
    - path: "cli/src/utils/code-execution/types.ts"
      provides: "FileOperation, ExecutionResult, BackupManifest, DependencySet, VerificationError, ExecutionError types"
      contains: "ExecutionResult"
    - path: "cli/src/utils/code-execution/file-operations.ts"
      provides: "writeFileAtomic, createBackup, restoreBackups, cleanupBackups, executeFileOperations"
      exports:
        ["writeFileAtomic", "createBackup", "restoreBackups", "cleanupBackups"]
    - path: "cli/src/utils/code-execution/dependency-installer.ts"
      provides: "installDependencies, collectDependencies"
      exports: ["installDependencies", "collectDependencies"]
  key_links:
    - from: "cli/src/utils/code-execution/file-operations.ts"
      to: "node:fs/promises"
      via: "atomic write (temp file + rename)"
      pattern: "rename.*tmp"
    - from: "cli/src/utils/code-execution/dependency-installer.ts"
      to: "cli/src/utils/package-manager.ts"
      via: "detectPackageManager, getInstallCommand"
      pattern: "detectPackageManager"
---

<objective>
Build the foundational types, atomic file operations (write, backup, restore), and dependency installer for Phase 5 code execution.

Purpose: These are the low-level building blocks that the execution orchestrator (Plan 05-02) composes into the full flow.
Output: Types, tested file operations module, tested dependency installer module.
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-code-execution/05-RESEARCH.md
@cli/src/utils/user-confirmation/types.ts
@cli/src/utils/plan-generation/types.ts
@cli/src/utils/plan-generation/schemas.ts
@cli/src/utils/package-manager.ts
@cli/src/utils/interactive.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Types and atomic file operations with TDD</name>
  <files>
    cli/src/utils/code-execution/types.ts
    cli/src/utils/code-execution/file-operations.ts
    cli/src/utils/code-execution/file-operations.test.ts
  </files>
  <action>
**Types (types.ts):**

Create all types for the code-execution module:

- `FileOperation`: `{ filePath: string; content: string; isNew: boolean }`
- `BackupManifest`: `{ backups: Map<string, string>; timestamp: string }` (maps originalPath -> backupPath)
- `DependencySet`: `{ dependencies: string[]; devDependencies: string[] }`
- `VerificationError`: `{ filePath: string; issue: string; suggestion: string }`
- `ExecutionError`: `{ phase: "file-write" | "dependency-install" | "verification"; filePath?: string; cause: string; suggestions: string[] }`
- `ExecutionResult`: `{ success: boolean; filesCreated: string[]; filesModified: string[]; dependenciesInstalled: string[]; errors: VerificationError[] }`

Import `InstallationPlan` from `../plan-generation/types.js` and `ConfirmationResult` from `../user-confirmation/types.js` for re-export convenience (type-only imports).

**File operations (file-operations.ts):**

Follow TDD: write failing tests FIRST, then implement.

`writeFileAtomic(filePath, content)`:

- Create parent directories with `fs.mkdir(dir, { recursive: true })`
- Write to temp file in SAME directory: `.${basename}.${crypto.randomUUID()}.tmp`
- Atomic rename to target path
- On error: clean up temp file, re-throw
- Tests: writes new file, overwrites existing file, creates parent dirs, cleans up temp on error

`createBackup(filePath, manifest)`:

- Check file exists (skip if ENOENT - new file, nothing to backup)
- Copy to `.${basename}.backup.${manifest.timestamp}` in same directory
- Add mapping to manifest.backups Map
- Tests: backs up existing file, skips non-existent file, records in manifest

`restoreBackups(manifest)`:

- Iterate manifest.backups, copy each backup back to original path
- Log restored files
- Tests: restores backed-up files, handles missing backup gracefully

`cleanupBackups(manifest)`:

- Delete all backup files from manifest
- Ignore cleanup errors silently
- Tests: removes backup files, ignores errors

`executeFileOperations(operations: FileOperation[])`:

- Calls writeFileAtomic for each operation sequentially
- Returns the operations array unchanged (for chaining)
- Tests: writes multiple files, stops on first error

Use real filesystem (write to OS temp dir) for tests, not memfs - these are fs operations that need real behavior. Use `os.tmpdir()` + unique subdirectory for test isolation, clean up in afterEach.
</action>
<verify>
Run `npm test -- --testPathPatterns='code-execution/file-operations' -w cli` — all tests pass.
Run `npm run check-types -w cli` — no type errors.
</verify>
<done>
Atomic file write creates files safely with temp+rename. Backup/restore works for existing files. All operations have passing tests.
</done>
</task>

<task type="auto">
  <name>Task 2: Dependency installer with TDD</name>
  <files>
    cli/src/utils/code-execution/dependency-installer.ts
    cli/src/utils/code-execution/dependency-installer.test.ts
  </files>
  <action>
Follow TDD: write failing tests FIRST, then implement.

`installDependencies(deps: DependencySet, options?: { yes?: boolean })`:

- Early return if both arrays empty
- Call `detectPackageManager()` from `../package-manager.js`
- Call `validatePackageManager(pm)` from same module
- Get install command and dev flag via existing utilities
- Use ora spinner for progress feedback
- Install production deps first (if any), then dev deps (if any)
- Use `execFileSync(pm, args, { stdio: "pipe", encoding: "utf-8", allowNonInteractive: Boolean(options.yes) })` from `../interactive.js`
- Format packages with `formatPackageArgs(pm, deps)` from `../package-manager.js`
- On success: spinner.succeed with count
- On error: spinner.fail, throw with descriptive message
- Tests: mock execFileSync and detectPackageManager. Test: skips when empty, installs prod deps, installs dev deps, installs both sequentially, throws on failure with message.

`collectDependencies(plan: InstallationPlan, selectedItems: string[])`:

- Always add `@tambo-ai/react` to dependencies
- If any selectedItem starts with "tool-": add `zod` to dependencies
- Return DependencySet
- Tests: always includes @tambo-ai/react, adds zod when tools selected, no zod when no tools

Mock `detectPackageManager`, `validatePackageManager`, `getInstallCommand`, `getDevFlag`, `formatPackageArgs` from `../package-manager.js` and `execFileSync` from `../interactive.js` in tests. Mock `ora` to return a stub spinner object.
</action>
<verify>
Run `npm test -- --testPathPatterns='code-execution/dependency-installer' -w cli` — all tests pass.
Run `npm run check-types -w cli` — no type errors.
</verify>
<done>
Dependencies are installed using detected package manager. Production and dev deps handled separately. collectDependencies extracts correct packages from plan. All tests pass.
</done>
</task>

</tasks>

<verification>
```bash
npm test -- --testPathPatterns='code-execution' -w cli
npm run check-types -w cli
npm run lint -w cli
```
All tests pass, no type errors, no lint errors.
</verification>

<success_criteria>

- Types defined for entire code-execution module
- Atomic file write with temp+rename pattern tested
- Backup/restore for existing files tested
- Dependency installer uses existing package-manager utilities
- All tests pass with real filesystem (file-operations) and mocks (dependency-installer)
  </success_criteria>

<output>
After completion, create `.planning/phases/05-code-execution/05-01-SUMMARY.md`
</output>
