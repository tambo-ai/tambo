---
phase: 01-client-core-sdk
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/client-core/package.json
  - packages/client-core/tsconfig.json
  - packages/client-core/tsconfig.cjs.json
  - packages/client-core/tsconfig.esm.json
  - packages/client-core/src/index.ts
  - packages/client-core/src/types.ts
  - packages/client-core/src/retry.ts
  - packages/client-core/src/client.ts
  - packages/client-core/jest.config.ts
  - packages/client-core/src/retry.test.ts
  - packages/client-core/src/client.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer can create TamboClient with API key and base URL"
    - "Client sends Authorization header on all requests"
    - "Failed requests retry with exponential backoff"
    - "Client errors on 4xx without retrying"
    - "Package builds to both CJS and ESM"
  artifacts:
    - path: "packages/client-core/package.json"
      provides: "Package definition with dual CJS/ESM exports"
      contains: "@tambo-ai/client-core"
    - path: "packages/client-core/src/client.ts"
      provides: "TamboClient class with authenticated fetch"
      exports: ["TamboClient"]
    - path: "packages/client-core/src/types.ts"
      provides: "Core type definitions"
      exports: ["TamboClientOptions"]
    - path: "packages/client-core/src/retry.ts"
      provides: "Retry wrapper with exponential backoff"
      exports: ["fetchWithRetry"]
  key_links:
    - from: "packages/client-core/src/client.ts"
      to: "packages/client-core/src/retry.ts"
      via: "import fetchWithRetry"
      pattern: "import.*fetchWithRetry.*from.*retry"
    - from: "packages/client-core/src/client.ts"
      to: "packages/client-core/src/types.ts"
      via: "import TamboClientOptions"
      pattern: "import.*TamboClientOptions.*from.*types"
---

<objective>
Set up the @tambo-ai/client-core package with build system, core types, TamboClient class with authenticated requests, and retry logic with exponential backoff.

Purpose: Foundation that all subsequent plans build on — package must exist, build, and make authenticated API calls before we add threads/streaming/tools.
Output: Working package with TamboClient that makes retried, authenticated fetch calls.
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-client-core-sdk/01-RESEARCH.md
@react-sdk/package.json (reference for dual build pattern)
@react-sdk/tsconfig.cjs.json (reference for CJS config)
@react-sdk/tsconfig.esm.json (reference for ESM config)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create package structure and build configuration</name>
  <files>
    packages/client-core/package.json
    packages/client-core/tsconfig.json
    packages/client-core/tsconfig.cjs.json
    packages/client-core/tsconfig.esm.json
    packages/client-core/jest.config.ts
    packages/client-core/src/index.ts
  </files>
  <action>
    Create packages/client-core/ as a new workspace package following the react-sdk dual build pattern.

    package.json:
    - name: "@tambo-ai/client-core"
    - main: "./dist/index.js", module: "./esm/index.js", types: "./dist/index.d.ts"
    - exports map with import/require/types (same pattern as react-sdk)
    - scripts: build (build:cjs + build:esm), build:cjs (tsc -p tsconfig.cjs.json), build:esm (tsc -p tsconfig.esm.json && tsc-esm-fix --target=esm), check-types (tsc --noEmit), test (jest), clean (rimraf dist esm coverage)
    - dependencies: exponential-backoff ^3.x, type-fest ^5.4.3
    - peerDependencies: zod "^3.25.76 || ^4"
    - devDependencies: @tambo-ai/typescript-config *, @tambo-ai/eslint-config *, typescript ^5.9.3, jest ^30.2.0, ts-jest ^29.4.6, @types/jest ^30.0.0, @types/node ^22.19.8, tsc-esm-fix ^3.1.2, rimraf ^6
    - NO React dependency — pure TypeScript

    tsconfig.json: extend @tambo-ai/typescript-config, strict mode, target ES2022, include src/**/*.ts
    tsconfig.cjs.json: extend ./tsconfig.json, module CommonJS, moduleResolution node, outDir ./dist, declaration true
    tsconfig.esm.json: extend ./tsconfig.json, module ESNext, moduleResolution bundler, outDir ./esm, declaration true

    jest.config.ts: use ts-jest preset, testEnvironment node

    src/index.ts: barrel file, initially empty (will export as types/client are added in next task)

    After creating files, run `npm install` from repo root to link the workspace package.

  </action>
  <verify>
    Run `npm run build -w packages/client-core` — should succeed with empty index.
    Run `npm run check-types -w packages/client-core` — should succeed.
  </verify>
  <done>Package exists in workspace, builds to dist/ and esm/, TypeScript compiles clean.</done>
</task>

<task type="auto">
  <name>Task 2: Implement types, retry logic, and TamboClient with tests</name>
  <files>
    packages/client-core/src/types.ts
    packages/client-core/src/retry.ts
    packages/client-core/src/client.ts
    packages/client-core/src/retry.test.ts
    packages/client-core/src/client.test.ts
    packages/client-core/src/index.ts
  </files>
  <action>
    src/types.ts — Core types:
    - TamboClientOptions interface: { apiKey: string; baseUrl?: string; timeout?: number; maxRetries?: number }
    - ApiError class extending Error with status, statusText, body fields
    - RequestOptions interface: { method?: string; body?: unknown; headers?: Record<string, string>; signal?: AbortSignal }

    src/retry.ts — Retry wrapper:
    - fetchWithRetry function using exponential-backoff library's backOff()
    - Accepts: fn () => Promise<T>, options { numOfAttempts, startingDelay, maxDelay, jitter }
    - Default: 3 attempts, 1000ms starting delay, 30000ms max, "full" jitter
    - retry callback: only retry on network errors or 5xx status (error.status >= 500 or no status). Do NOT retry 4xx.
    - Export fetchWithRetry

    src/client.ts — TamboClient class:
    - Constructor takes TamboClientOptions, validates apiKey is non-empty (throw if missing)
    - Store apiKey, baseUrl (default "https://api.tambo.co"), timeout (default 30000), maxRetries (default 3)
    - Private method request<T>(path: string, options?: RequestOptions): Promise<T>
      - Builds full URL from baseUrl + path
      - Sets headers: Authorization Bearer {apiKey}, Content-Type application/json
      - Merges any extra headers from options
      - Creates AbortController with setTimeout for timeout
      - Wraps fetch call in fetchWithRetry with configured maxRetries
      - On non-ok response: throw ApiError with status, statusText, and parsed body
      - On success: return response.json() as T
    - Public methods (stubs for now, will be implemented in Plan 02):
      - No public methods yet beyond the constructor — request() is protected so subclasses/later code can use it
    - Actually, make request() a public method since we'll use composition not inheritance. Name it `fetch` to be clear:
      - public async fetch<T>(path: string, options?: RequestOptions): Promise<T>

    src/retry.test.ts — Tests for retry:
    - Test: retries on network error (mock fetch throwing TypeError)
    - Test: retries on 500 status
    - Test: does NOT retry on 400 status
    - Test: respects maxRetries limit
    - Mock exponential-backoff or use real timers with jest.useFakeTimers

    src/client.test.ts — Tests for TamboClient:
    - Test: throws if apiKey is empty string
    - Test: sends Authorization header with Bearer token
    - Test: uses default baseUrl when not provided
    - Test: throws ApiError on 404 response
    - Test: returns parsed JSON on success
    - Mock global fetch

    src/index.ts — Export everything:
    - export { TamboClient } from "./client"
    - export { fetchWithRetry } from "./retry"
    - export { ApiError } from "./types"
    - export type { TamboClientOptions, RequestOptions } from "./types"

  </action>
  <verify>
    Run `npm test -w packages/client-core` — all tests pass.
    Run `npm run build -w packages/client-core` — builds clean.
    Run `npm run check-types -w packages/client-core` — no type errors.
  </verify>
  <done>TamboClient can be instantiated with API key, makes authenticated fetch calls with retry on 5xx/network errors, throws on 4xx, all tests pass, package builds.</done>
</task>

</tasks>

<verification>
- `npm run build -w packages/client-core` produces dist/ and esm/ directories
- `npm test -w packages/client-core` passes all tests
- `npm run check-types -w packages/client-core` clean
- Can import { TamboClient } from the built package
</verification>

<success_criteria>

- Package @tambo-ai/client-core exists in workspace and builds dual CJS/ESM
- TamboClient accepts apiKey + baseUrl, sends authenticated requests
- Retry logic retries 5xx/network errors with exponential backoff, skips 4xx
- All public APIs fully typed, tests passing
  </success_criteria>

<output>
After completion, create `.planning/phases/01-client-core-sdk/01-01-SUMMARY.md`
</output>
