---
phase: 01-client-core-sdk
plan: 05
type: execute
wave: 4
depends_on: ["01-03", "01-04"]
files_modified:
  - packages/client-core/src/tools.ts
  - packages/client-core/src/tools.test.ts
  - packages/client-core/src/run.ts
  - packages/client-core/src/run.test.ts
  - packages/client-core/src/types.ts
  - packages/client-core/src/client.ts
  - packages/client-core/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Developer can register tools with Zod schemas"
    - "Client handles tool call/result loop automatically"
    - "Tool args are validated with Zod before execution"
    - "Tool errors are caught and sent back as error results"
    - "Multi-round tool loops complete (tool->AI->tool->AI)"
    - "Developer can send a message and get full streamed response with tool execution"
  artifacts:
    - path: "packages/client-core/src/tools.ts"
      provides: "Tool registry with Zod validation"
      exports: ["ToolRegistry"]
    - path: "packages/client-core/src/run.ts"
      provides: "Run execution with streaming + tool loop"
      exports: ["executeRun"]
  key_links:
    - from: "packages/client-core/src/run.ts"
      to: "packages/client-core/src/streaming.ts"
      via: "uses stream() for SSE events"
      pattern: "import.*stream"
    - from: "packages/client-core/src/run.ts"
      to: "packages/client-core/src/tools.ts"
      via: "uses ToolRegistry to execute tool calls"
      pattern: "registry.*execute"
    - from: "packages/client-core/src/client.ts"
      to: "packages/client-core/src/run.ts"
      via: "exposes run method on client"
      pattern: "import.*from.*run"
---

<objective>
Implement tool registry with Zod validation and the run execution loop that streams responses and handles tool call/result cycles automatically.

Purpose: SDK-05 (tool registration), SDK-06 (automatic tool loop) — the agent capability that makes client-core useful for the CLI's init flow.
Output: ToolRegistry for registering tools, executeRun that streams a thread run and handles tool calls end-to-end.
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-client-core-sdk/01-RESEARCH.md
@.planning/phases/01-client-core-sdk/01-01-SUMMARY.md
@.planning/phases/01-client-core-sdk/01-02-SUMMARY.md
@.planning/phases/01-client-core-sdk/01-03-SUMMARY.md
@.planning/phases/01-client-core-sdk/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ToolRegistry with Zod validation</name>
  <files>
    packages/client-core/src/types.ts
    packages/client-core/src/tools.ts
    packages/client-core/src/tools.test.ts
  </files>
  <action>
    src/types.ts — Add tool types:
    - ToolDefinition<TInput = unknown, TOutput = unknown>: { name: string; description: string; inputSchema: z.ZodSchema<TInput>; outputSchema?: z.ZodSchema<TOutput>; execute: (input: TInput) => Promise<TOutput> }
    - ToolResult: { toolUseId: string; content: ContentPart[]; isError?: boolean }

    src/tools.ts — ToolRegistry class:
    - private tools: Map<string, ToolDefinition>
    - register<TInput, TOutput>(tool: ToolDefinition<TInput, TOutput>): void — throws if name already registered
    - has(name: string): boolean
    - execute(name: string, toolUseId: string, rawArgs: string): Promise<ToolResult>
      - Get tool from map, throw if not found
      - JSON.parse rawArgs
      - Validate with tool.inputSchema.parse()
      - Call tool.execute() with validated args
      - Return ToolResult with stringified result as text content
      - On any error (parse, validation, execution): return ToolResult with isError: true and error message
    - toApiFormat(): array of { name, description, inputSchema } for sending to API (convert Zod schema to JSON Schema using zod's .describe or manual conversion — check what the API expects)
    - clear(): void — remove all tools

    src/tools.test.ts — Tests:
    - Test: register and execute tool with valid args
    - Test: throws on duplicate registration
    - Test: returns error result for unknown tool
    - Test: validates args with Zod, returns error on invalid
    - Test: catches execution errors and returns as error result
    - Test: toApiFormat returns correct shape
    - Test: has() returns true/false correctly

  </action>
  <verify>
    Run `npm test -w packages/client-core -- --testPathPattern=tools` — tests pass.
    Run `npm run check-types -w packages/client-core` — clean.
  </verify>
  <done>ToolRegistry registers tools, validates with Zod, executes, handles errors, converts to API format.</done>
</task>

<task type="auto">
  <name>Task 2: Implement run execution with streaming + tool loop</name>
  <files>
    packages/client-core/src/run.ts
    packages/client-core/src/run.test.ts
    packages/client-core/src/client.ts
    packages/client-core/src/index.ts
  </files>
  <action>
    src/run.ts — Run execution:
    - RunOptions: { tools?: ToolRegistry; onEvent?: (event: StreamEvent) => void; signal?: AbortSignal; maxToolRounds?: number }
    - async function executeRun(client: TamboClient, threadId: string, message: SendMessageParams, options?: RunOptions): Promise<Message>
      - Convert string message to ContentPart array if needed
      - Build request body with message content and tool definitions (from registry.toApiFormat() if tools provided)
      - Start streaming via typescript-sdk's sdk.threads.runs.run() or the streaming module from plan 01-04
      - Collect events, call options.onEvent for each
      - Track tool calls: on tool_call_start, accumulate args from tool_call_args, execute on tool_call_end
      - When all tool calls in a round complete:
        - Send tool results back via typescript-sdk (check sdk.threads.runs for tool result submission method)
        - Start new stream for the next round
      - Track rounds, throw if exceeds maxToolRounds (default 10) to prevent infinite loops
      - On message_end or done: return the final Message
      - Buffer tool_call_args per toolCallId (partial JSON accumulation from research pitfall #2)

    src/client.ts — Add run method and tool registration:
    - private toolRegistry: ToolRegistry (created in constructor)
    - public registerTool<TInput, TOutput>(tool: ToolDefinition<TInput, TOutput>): void — delegates to toolRegistry
    - public async run(threadId: string, message: SendMessageParams, options?: Omit<RunOptions, "tools">): Promise<Message>
      - Calls executeRun with this, threadId, message, { ...options, tools: this.toolRegistry }
    - public async *streamRun(threadId: string, message: SendMessageParams, options?: Omit<RunOptions, "tools">): AsyncGenerator<StreamEvent>
      - Lower-level: streams events without auto-completing tool loop (for consumers who want manual control)
      - Just delegates to client.stream with the right path and body

    src/index.ts — Add exports:
    - export { ToolRegistry } from "./tools"
    - export { executeRun } from "./run"
    - export type { ToolDefinition, ToolResult, RunOptions } from "./types"

    src/run.test.ts — Tests:
    - Test: simple message (no tools) streams to completion, returns final Message
    - Test: tool call round: stream has tool events -> executes tool -> sends results -> gets final response
    - Test: multi-round tool loop (2 rounds) completes
    - Test: maxToolRounds exceeded throws error
    - Test: onEvent callback called for each event
    - Test: signal cancellation stops run
    - Mock typescript-sdk client methods and streaming as needed.

  </action>
  <verify>
    Run `npm test -w packages/client-core` — all tests pass.
    Run `npm run build -w packages/client-core` — builds clean.
    Run `npm run check-types -w packages/client-core` — clean.
    Run `npm run lint -w packages/client-core` — clean (or lint from root).
  </verify>
  <done>Full run execution with streaming + automatic tool loop works. Developer registers tools, calls client.run(), gets back final Message after any tool rounds complete automatically.</done>
</task>

</tasks>

<verification>
- `npm test -w packages/client-core` — all tests pass (tools + run + prior tests)
- `npm run build -w packages/client-core` — clean dual build
- `npm run check-types -w packages/client-core` — no errors
- Full flow works: create client -> register tool -> create thread -> run with message -> tool executes -> final response returned
</verification>

<success_criteria>

- Tools registered with Zod schemas, validated at runtime
- executeRun handles full tool call/result loop automatically
- Multi-round tool loops work (tool->AI->tool->AI->done)
- maxToolRounds prevents infinite loops
- All public APIs typed with full inference (ToolDefinition generic params flow through)
- Package builds, tests pass, types check
  </success_criteria>

<output>
After completion, create `.planning/phases/01-client-core-sdk/01-05-SUMMARY.md`
</output>
