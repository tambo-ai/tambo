---
phase: 01-websocket-bridge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - react-sdk/src/devtools/index.ts
  - react-sdk/src/devtools/devtools-protocol.ts
  - react-sdk/src/devtools/devtools-bridge.ts
  - react-sdk/src/devtools/tambo-dev-tools.tsx
  - react-sdk/package.json
autonomous: true

must_haves:
  truths:
    - "Importing @tambo-ai/react/devtools resolves to the devtools subpath entry point"
    - "TamboDevTools component establishes a WebSocket connection to ws://localhost:8265 on mount"
    - "TamboDevTools component sends a handshake message with sdkVersion, projectId, and sessionId"
    - "TamboDevTools component disconnects cleanly on unmount"
    - "Main entry point @tambo-ai/react does NOT import or re-export anything from devtools/"
  artifacts:
    - path: "react-sdk/src/devtools/devtools-protocol.ts"
      provides: "Wire protocol type definitions (DevToolsMessage, DevToolsServerMessage discriminated unions)"
      contains: "type DevToolsMessage"
    - path: "react-sdk/src/devtools/devtools-bridge.ts"
      provides: "WebSocket client class using partysocket with auto-reconnect"
      contains: "class DevToolsBridge"
    - path: "react-sdk/src/devtools/tambo-dev-tools.tsx"
      provides: "TamboDevTools React component (renders null, manages bridge lifecycle)"
      exports: ["TamboDevTools"]
    - path: "react-sdk/src/devtools/index.ts"
      provides: "Subpath export entry point"
      exports: ["TamboDevTools"]
    - path: "react-sdk/package.json"
      provides: "exports field with ./devtools subpath"
      contains: "./devtools"
  key_links:
    - from: "react-sdk/src/devtools/tambo-dev-tools.tsx"
      to: "react-sdk/src/devtools/devtools-bridge.ts"
      via: "useEffect creates DevToolsBridge instance, connects on mount, disconnects on cleanup"
      pattern: "new DevToolsBridge"
    - from: "react-sdk/src/devtools/devtools-bridge.ts"
      to: "react-sdk/src/devtools/devtools-protocol.ts"
      via: "send() accepts DevToolsMessage union type"
      pattern: "DevToolsMessage"
    - from: "react-sdk/src/devtools/index.ts"
      to: "react-sdk/src/devtools/tambo-dev-tools.tsx"
      via: "re-export"
      pattern: "export.*TamboDevTools"
---

<objective>
Create the SDK-side devtools bridge: wire protocol types, WebSocket client with auto-reconnect, TamboDevTools React component, and the `@tambo-ai/react/devtools` subpath export.

Purpose: This is the SDK half of the WebSocket bridge. It gives developers a `<TamboDevTools />` component that, when rendered inside `<TamboProvider>`, establishes a WebSocket connection to the local devtools server and sends a handshake with SDK metadata. This plan covers INFRA-01 (SDK emits events), INFRA-04 (auto-reconnect), INFRA-05 (subpath isolation), and INFRA-06 (explicit opt-in).

Output: `react-sdk/src/devtools/` directory with 4 files, updated `package.json` exports field, `partysocket` dependency installed.
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-websocket-bridge/01-RESEARCH.md

@react-sdk/package.json
@react-sdk/src/index.ts
@react-sdk/src/mcp/index.ts
@react-sdk/src/v1/providers/tambo-v1-provider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install partysocket and create wire protocol types</name>
  <files>react-sdk/src/devtools/devtools-protocol.ts</files>
  <action>
Install `partysocket` as a dependency in react-sdk:
```
npm install partysocket -w react-sdk
```

Create `react-sdk/src/devtools/devtools-protocol.ts` defining the wire protocol as TypeScript discriminated unions:

**SDK -> Server messages (`DevToolsMessage`):**

- `handshake`: `{ type: "handshake", protocolVersion: 1, sdkVersion: string, projectId: string | undefined, sessionId: string }`
- `state_snapshot`: `{ type: "state_snapshot", sessionId: string, timestamp: number, threads: Array<{ id: string, name?: string, status: "idle" | "streaming" | "waiting", messageCount: number }>, registry: { components: Array<{ name: string, description: string }>, tools: Array<{ name: string, description: string }> } }`
- `heartbeat`: `{ type: "heartbeat", sessionId: string, timestamp: number }`

**Server -> SDK messages (`DevToolsServerMessage`):**

- `handshake_ack`: `{ type: "handshake_ack", sessionId: string, serverVersion: string }`
- `request_snapshot`: `{ type: "request_snapshot" }`

**Server -> Dashboard messages (`DevToolsDashboardMessage`):**

- `client_connected`: `{ type: "client_connected", sessionId: string, sdkVersion: string, projectId?: string }`
- `client_disconnected`: `{ type: "client_disconnected", sessionId: string }`
- `state_update`: `{ type: "state_update", sessionId: string, snapshot: DevToolsStateSnapshot }`
- `client_list`: `{ type: "client_list", clients: Array<{ sessionId: string, sdkVersion: string, projectId?: string, connectedAt: number }> }`

**Dashboard -> Server messages (`DevToolsDashboardCommand`):**

- `request_client_list`: `{ type: "request_client_list" }`
- `request_client_snapshot`: `{ type: "request_client_snapshot", sessionId: string }`

Also export constants: `DEVTOOLS_DEFAULT_PORT = 8265`, `DEVTOOLS_DEFAULT_HOST = "localhost"`, `DEVTOOLS_PROTOCOL_VERSION = 1`.

Use `export type` for all type exports and `export const` for constants. Do NOT use zod schemas here -- keep this file pure TypeScript types for zero runtime cost when tree-shaken. The server side will validate at runtime with its own logic.
</action>
<verify>
`npx tsc --noEmit -p react-sdk/tsconfig.cjs.json` passes with no errors related to devtools-protocol.ts.
</verify>
<done>
devtools-protocol.ts exports DevToolsMessage, DevToolsServerMessage, DevToolsDashboardMessage, DevToolsDashboardCommand discriminated unions and port/host/version constants. partysocket is in react-sdk/package.json dependencies.
</done>
</task>

<task type="auto">
  <name>Task 2: Create DevToolsBridge client and TamboDevTools component with subpath export</name>
  <files>
    react-sdk/src/devtools/devtools-bridge.ts
    react-sdk/src/devtools/tambo-dev-tools.tsx
    react-sdk/src/devtools/index.ts
    react-sdk/package.json
  </files>
  <action>
**1. Create `react-sdk/src/devtools/devtools-bridge.ts`:**

A class `DevToolsBridge` that wraps `partysocket`'s `WebSocket` (import as `import { WebSocket as ReconnectingWebSocket } from "partysocket"`).

Constructor takes `DevToolsBridgeOptions`:

```typescript
interface DevToolsBridgeOptions {
  host?: string; // defaults to DEVTOOLS_DEFAULT_HOST
  port?: number; // defaults to DEVTOOLS_DEFAULT_PORT
  sessionId: string;
  sdkVersion: string;
  projectId?: string;
}
```

Methods:

- `connect(): void` -- Creates `ReconnectingWebSocket` to `ws://{host}:{port}`. On open, sends handshake message. Configures partysocket options: `maxReconnectionDelay: 10_000`, `minReconnectionDelay: 1_000`, `reconnectionDelayGrowFactor: 1.3`, `connectionTimeout: 4_000`, `maxRetries: Infinity`, `maxEnqueuedMessages: 0` (zero buffering when disconnected per research P10).
- `send(message: DevToolsMessage): void` -- Only sends if connected. Serializes with `JSON.stringify` (superjson deferred to Phase 2 when state snapshots contain Dates/Maps).
- `disconnect(): void` -- Closes WS, sets ws to null, sets connected to false.
- `get isConnected(): boolean` -- Returns connection state.

Track connection state with a private `connected` boolean. Listen to `open` and `close` events on the ReconnectingWebSocket to update it. Listen for `message` events to handle `handshake_ack` and `request_snapshot` from server (log ack for now, ignore request_snapshot in Phase 1).

**2. Create `react-sdk/src/devtools/tambo-dev-tools.tsx`:**

Add `"use client"` directive at top.

Export `TamboDevToolsProps` interface with optional `port?: number` and `host?: string`.

Export `TamboDevTools` function component that:

- Returns `null` (renders nothing visible).
- Uses `useRef<DevToolsBridge | null>(null)` to hold bridge instance (avoids duplicates in StrictMode).
- In a `useEffect` (deps: `[host, port]`):
  - Creates a new `DevToolsBridge` with `sessionId: crypto.randomUUID()`, `sdkVersion` read from a constant (hardcode `"1.0.1"` for now -- SDK version injection is an open question from research, to be automated in a follow-up).
  - For `projectId`: attempt to read from TamboProvider's context. Import and use `useTamboAuthState` from `../../v1/hooks/use-tambo-v1-auth-state` (this hook returns `{ projectId }` from the client provider). If the hook throws (component not inside TamboProvider), catch and omit projectId. Actually, since TamboDevTools is documented to be rendered inside TamboProvider, just call useTamboAuthState() directly. But do this OUTSIDE the useEffect -- read projectId from the hook at component level, pass it into the useEffect via the dependency array.
  - Calls `bridge.connect()`.
  - Cleanup: calls `bridge.disconnect()`, sets ref to null.
- Add JSDoc explaining this is an opt-in devtools bridge that renders nothing visible and should be placed inside TamboProvider.

**Important React lifecycle handling (from research P2):**

- Use a ref to prevent double-connection in StrictMode. In the effect, check if `bridgeRef.current` is already set and skip creating a new one. On cleanup, disconnect and null the ref.
- Actually, the standard pattern is simpler: just create fresh each time the effect runs and disconnect on cleanup. StrictMode will create-cleanup-create which is the correct behavior (old connection is properly cleaned up). Don't try to be clever with refs to deduplicate -- that leads to stale connections.

**3. Create `react-sdk/src/devtools/index.ts`:**

Follow the pattern from `react-sdk/src/mcp/index.ts`. Re-export public symbols:

```typescript
export { TamboDevTools } from "./tambo-dev-tools";
export type { TamboDevToolsProps } from "./tambo-dev-tools";
export type {
  DevToolsMessage,
  DevToolsServerMessage,
  DevToolsDashboardMessage,
  DevToolsDashboardCommand,
  DEVTOOLS_DEFAULT_PORT,
  DEVTOOLS_DEFAULT_HOST,
  DEVTOOLS_PROTOCOL_VERSION,
} from "./devtools-protocol";
```

Note: export the constants with `export { ... }` not `export type { ... }`.

**4. Update `react-sdk/package.json` exports field:**

Add `"./devtools"` entry following the exact same pattern as `"./mcp"`:

```json
"./devtools": {
  "import": "./esm/devtools/index.js",
  "require": "./dist/devtools/index.js",
  "types": "./dist/devtools/index.d.ts"
}
```

**CRITICAL: Do NOT add any import of devtools/ anywhere in react-sdk/src/index.ts or react-sdk/src/v1/index.ts.** The devtools code must be completely isolated behind the subpath export.

**5. Verify isolation:**

After creating all files, confirm that `react-sdk/src/index.ts` still only exports `./v1/index` and does NOT reference devtools anywhere.
</action>
<verify>

1. `npm run build -w react-sdk` succeeds (both CJS and ESM builds complete).
2. `ls react-sdk/dist/devtools/index.js react-sdk/esm/devtools/index.js` -- both files exist.
3. `grep -r "devtools" react-sdk/src/index.ts react-sdk/src/v1/index.ts` returns no matches (isolation verified).
4. `npm run check-types -w react-sdk` passes.
   </verify>
   <done>
   DevToolsBridge class connects via partysocket with auto-reconnect and sends handshake. TamboDevTools renders null, manages bridge lifecycle in useEffect. Subpath export `@tambo-ai/react/devtools` resolves correctly in both CJS and ESM. Main entry point does not reference devtools.
   </done>
   </task>

</tasks>

<verification>
1. `npm run build -w react-sdk` passes -- both CJS and ESM outputs include devtools/.
2. `npm run check-types -w react-sdk` passes -- no type errors.
3. `npm run lint -w react-sdk` passes -- no lint violations.
4. `grep -rn "devtools" react-sdk/src/index.ts react-sdk/src/v1/` returns zero results -- devtools is isolated.
5. Both `react-sdk/dist/devtools/index.js` and `react-sdk/esm/devtools/index.js` exist after build.
</verification>

<success_criteria>

- `@tambo-ai/react/devtools` subpath export resolves (build outputs exist at correct paths)
- DevToolsBridge class uses partysocket with auto-reconnect config matching research specs
- TamboDevTools component manages bridge lifecycle correctly (connect on mount, disconnect on unmount)
- Handshake message includes protocolVersion, sdkVersion, sessionId, and projectId
- Zero devtools code reachable from `@tambo-ai/react` main entry point
- All existing tests still pass (`npm test -w react-sdk`)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-websocket-bridge/01-01-SUMMARY.md`
</output>
