---
phase: 02-codebase-analysis
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - cli/src/utils/project-analysis/provider-detection.ts
  - cli/src/utils/project-analysis/provider-detection.test.ts
  - cli/src/utils/project-analysis/component-detection.ts
  - cli/src/utils/project-analysis/component-detection.test.ts
autonomous: true
must_haves:
  truths:
    - "CLI detects existing provider components in layout/root files"
    - "CLI identifies React components that could become Tambo interactables"
  artifacts:
    - path: "cli/src/utils/project-analysis/provider-detection.ts"
      provides: "AST-based provider detection using ts-morph"
      exports: ["detectProviders"]
    - path: "cli/src/utils/project-analysis/component-detection.ts"
      provides: "AST-based React component detection for interactable candidates"
      exports: ["detectComponents"]
  key_links:
    - from: "cli/src/utils/project-analysis/provider-detection.ts"
      to: "ts-morph"
      via: "Project, SyntaxKind imports"
      pattern: "import.*ts-morph"
    - from: "cli/src/utils/project-analysis/component-detection.ts"
      to: "ts-morph"
      via: "Project, SyntaxKind imports"
      pattern: "import.*ts-morph"
---

<objective>
Build AST-based detection modules using ts-morph: provider detection (finds existing React Context providers in layout files) and component detection (identifies React components that could become Tambo interactables).

Purpose: These modules use TypeScript AST parsing to understand the semantic structure of user code, enabling intelligent recommendations about where to insert TamboProvider and which components to register.
Output: provider-detection.ts and component-detection.ts with tests in cli/src/utils/project-analysis/
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-codebase-analysis/02-RESEARCH.md
@cli/src/commands/add/tailwind/config/parsing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Provider detection with ts-morph</name>
  <files>
    cli/src/utils/project-analysis/provider-detection.ts
    cli/src/utils/project-analysis/provider-detection.test.ts
  </files>
  <action>
**provider-detection.ts**:
- `detectProviders(layoutFilePath: string): ProviderInfo[]` (import ProviderInfo from ./types)
- Create a new `Project({ skipFileDependencyResolution: true, compilerOptions: { allowJs: true, jsx: 4 } })` — use ts.JsxEmit.JsxPreserve (numeric value 4) or import JsxEmit from ts-morph.
- Add the layout file to the project with `addSourceFileAtPath`.
- Find all JSX elements (SyntaxKind.JsxElement) whose tag name ends with "Provider".
- Also check JsxSelfClosingElement for self-closing providers.
- For each provider found:
  - Extract tag name from opening element
  - Find matching import declaration to get importSource (module specifier)
  - Calculate nesting level by counting JsxElement ancestors
  - Return `{ name, importSource, filePath: layoutFilePath, nestingLevel }`
- Sort by nestingLevel ascending (outermost first).
- Handle edge cases: file doesn't exist (return []), no providers found (return []), provider imported via default import.

**provider-detection.test.ts**:

- Test with a layout file containing ThemeProvider and AuthProvider nested:
  ```tsx
  import { ThemeProvider } from "next-themes";
  import { AuthProvider } from "@/contexts/auth";
  export default function RootLayout({ children }) {
    return (
      <ThemeProvider>
        <AuthProvider>{children}</AuthProvider>
      </ThemeProvider>
    );
  }
  ```
  Should detect both providers with correct nesting levels and import sources.
- Test with no providers (plain layout returning children) — returns [].
- Test with self-closing provider element.
- For tests: write temp files to disk using `fs.mkdtempSync` + `fs.writeFileSync` (ts-morph needs real files on disk, memfs won't work). Clean up in afterEach.
  </action>
  <verify>
  Run `npm test -w cli -- --testPathPattern="project-analysis/provider-detection"` and all tests pass.
  </verify>
  <done>
  Provider detection finds all \*Provider components in layout files with correct import sources and nesting levels. Tests pass using real temp files.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Component detection for interactable candidates</name>
  <files>
    cli/src/utils/project-analysis/component-detection.ts
    cli/src/utils/project-analysis/component-detection.test.ts
  </files>
  <action>
**component-detection.ts**:
- `detectComponents(componentsDirs: string[]): ComponentInfo[]` (import ComponentInfo from ./types)
- For each directory in componentsDirs:
  - Find all .tsx, .jsx, .ts, .js files (skip .test., .spec., .stories., .d.ts files)
  - Create a new `Project({ skipFileDependencyResolution: true, compilerOptions: { allowJs: true, jsx: 4 } })` per directory (per research: avoid AST memory leaks by not reusing across dirs)
  - For each file, find React components:
    - **Function declarations**: Name starts with uppercase, has JSX return (check ReturnStatement descendants for JsxElement, JsxFragment, or JsxSelfClosingElement kinds)
    - **Arrow functions in variable declarations**: Variable name starts with uppercase, initializer is arrow function, body contains JSX
    - **React.FC typed variables**: Variable has type annotation containing "React.FC" or "FC<"
  - For each component found, extract:
    - `name`: function/variable name
    - `filePath`: absolute path
    - `isExported`: check if function/variable has export keyword or is in export statement
    - `hasProps`: check if function has parameters (first param is not empty)
    - `propsInterface`: if first param has type annotation, extract the type name
    - `hooks`: find all call expressions matching /^use[A-Z]/ pattern within the function body
- Filter: only include exported components (non-exported are internal/private).
- Limit: cap at 50 components total (sorted by file path) to avoid overwhelming results per research pitfall #4.
- Skip files larger than 50KB (likely generated/bundled).

**component-detection.test.ts**:

- Test with directory containing:
  - A simple exported component with props and useState hook
  - An arrow function component with React.FC type
  - A non-exported helper component (should be filtered out)
  - A test file (should be skipped)
- Verify correct name, isExported, hasProps, hooks extraction.
- Use real temp files (ts-morph requirement), clean up in afterEach.
  </action>
  <verify>
  Run `npm test -w cli -- --testPathPattern="project-analysis/component-detection"` and all tests pass.
  Run `npm run check-types -w cli` with no errors.
  </verify>
  <done>
  Component detection identifies exported React components with props and hook usage. Non-exported components and test files are filtered. Results capped at 50. All tests pass.
  </done>
  </task>

</tasks>

<verification>
- `npm test -w cli -- --testPathPattern="project-analysis/(provider|component)-detection"` — all tests pass
- `npm run check-types -w cli` — no type errors
- `npm run lint -w cli` — no lint errors
</verification>

<success_criteria>

- Provider detection finds \*Provider JSX elements with correct import sources and nesting levels
- Component detection identifies exported React functional components (both function declarations and arrow functions)
- Component detection extracts props interface names and hook usage
- Test files, story files, and non-exported components are filtered out
- ts-morph Project instances are created per-directory (no memory accumulation)
- All tests pass with real temp files
  </success_criteria>

<output>
After completion, create `.planning/phases/02-codebase-analysis/02-02-SUMMARY.md`
</output>
