---
phase: 02-codebase-analysis
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - cli/src/utils/project-analysis/tool-detection.ts
  - cli/src/utils/project-analysis/tool-detection.test.ts
  - cli/src/utils/project-analysis/index.ts
  - cli/src/utils/project-analysis/index.test.ts
autonomous: true
must_haves:
  truths:
    - "CLI identifies existing functions or API calls that could become Tambo tools"
    - "CLI produces a complete ProjectAnalysis object from a single analyzeProject() call"
  artifacts:
    - path: "cli/src/utils/project-analysis/tool-detection.ts"
      provides: "Detection of fetch calls, server actions, and exported functions as tool candidates"
      exports: ["detectToolCandidates"]
    - path: "cli/src/utils/project-analysis/index.ts"
      provides: "Main orchestrator that combines all detection modules"
      exports: ["analyzeProject"]
  key_links:
    - from: "cli/src/utils/project-analysis/index.ts"
      to: "cli/src/utils/project-analysis/framework-detection.ts"
      via: "calls detectFrameworkInfo"
      pattern: "detectFrameworkInfo"
    - from: "cli/src/utils/project-analysis/index.ts"
      to: "cli/src/utils/project-analysis/structure-detection.ts"
      via: "calls detectProjectStructure and detectTypeScriptConfig"
      pattern: "detectProjectStructure|detectTypeScriptConfig"
    - from: "cli/src/utils/project-analysis/index.ts"
      to: "cli/src/utils/project-analysis/provider-detection.ts"
      via: "calls detectProviders with rootLayoutPath"
      pattern: "detectProviders"
    - from: "cli/src/utils/project-analysis/index.ts"
      to: "cli/src/utils/project-analysis/component-detection.ts"
      via: "calls detectComponents with componentsDirs"
      pattern: "detectComponents"
    - from: "cli/src/utils/project-analysis/index.ts"
      to: "cli/src/utils/project-analysis/tool-detection.ts"
      via: "calls detectToolCandidates"
      pattern: "detectToolCandidates"
    - from: "cli/src/utils/project-analysis/index.ts"
      to: "cli/src/utils/package-manager.ts"
      via: "calls existing detectPackageManager"
      pattern: "detectPackageManager"
---

<objective>
Build tool detection (finds functions/API calls that could become Tambo tools) and the main analyzeProject() orchestrator that combines all detection modules into a single ProjectAnalysis result.

Purpose: Tool detection completes the scanning capabilities. The orchestrator provides a single entry point for Phase 3 (Plan Generation) to call and get comprehensive project analysis.
Output: tool-detection.ts and index.ts (orchestrator) with tests in cli/src/utils/project-analysis/
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-codebase-analysis/02-RESEARCH.md
@.planning/phases/02-codebase-analysis/02-01-SUMMARY.md
@.planning/phases/02-codebase-analysis/02-02-SUMMARY.md
@cli/src/utils/package-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tool candidate detection</name>
  <files>
    cli/src/utils/project-analysis/tool-detection.ts
    cli/src/utils/project-analysis/tool-detection.test.ts
  </files>
  <action>
**tool-detection.ts**:
- `detectToolCandidates(projectRoot: string, options?: { exclude?: string[] }): ToolCandidate[]` (import ToolCandidate from ./types)
- Scan .ts and .tsx files in the project (use findFilesRecursively from ./fs-helpers). Default exclude: node_modules, .next, dist, build, .git. Also skip test/spec/stories files.
- Create new ts-morph Project per batch of files (group by directory to limit memory).
- For each source file, detect three categories:

1. **Server actions** (Next.js "use server"): Look for files containing `"use server"` directive at top level, or functions with `"use server"` directive. Extract function name, file path. Type: "server-action". Extract JSDoc description if present.

2. **Fetch/axios calls in exported functions**: Find exported functions that contain `fetch()` or `axios.*()` call expressions. Extract function name, file path. Type: "fetch" or "axios".

3. **Exported async functions** (general tool candidates): Find exported async functions that are NOT React components (name doesn't start with uppercase, or doesn't return JSX). These are potential tool wrappers. Type: "exported-function". Extract JSDoc description.

- Deduplicate: if a function is both a server action and an exported async function, prefer "server-action" type.
- Cap at 30 candidates total (sorted by file path then name).
- Skip files larger than 50KB.

**tool-detection.test.ts**:

- Test with files containing:
  - A "use server" file with async functions (should detect as server-action)
  - A utility file with exported async function calling fetch (should detect as fetch)
  - A React component file (should NOT appear as tool candidate)
- Use real temp files, clean up in afterEach.
  </action>
  <verify>
  Run `npm test -w cli -- --testPathPattern="project-analysis/tool-detection"` and all tests pass.
  </verify>
  <done>
  Tool detection identifies server actions, fetch-calling functions, and exported async functions as candidates. React components are excluded. Results capped at 30.
  </done>
  </task>

<task type="auto">
  <name>Task 2: analyzeProject orchestrator and module index</name>
  <files>
    cli/src/utils/project-analysis/index.ts
    cli/src/utils/project-analysis/index.test.ts
  </files>
  <action>
**index.ts** - Main entry point:
- `analyzeProject(projectRoot: string): ProjectAnalysis`
- Orchestrate all detection in order:
  1. `detectFrameworkInfo(projectRoot)` -> framework
  2. `detectProjectStructure(projectRoot, framework)` -> structure
  3. `detectTypeScriptConfig(projectRoot)` -> typescript
  4. `detectPackageManager(projectRoot)` from existing `cli/src/utils/package-manager.ts` -> packageManager
  5. If structure.rootLayoutPath exists: `detectProviders(structure.rootLayoutPath)` -> providers, else []
  6. If structure.componentsDirs.length > 0: `detectComponents(structure.componentsDirs)` -> components, else []
  7. `detectToolCandidates(projectRoot)` -> toolCandidates
  8. Return complete ProjectAnalysis object
- Also re-export all types from ./types for convenient imports: `export type { ProjectAnalysis, FrameworkInfo, ... } from "./types"`
- Re-export individual detection functions for direct use if needed.

**index.test.ts** - Integration test:

- Create a temp directory simulating a Next.js App Router project:
  - package.json with "next" dependency
  - src/app/layout.tsx with a ThemeProvider
  - src/components/ with one exported React component
  - src/actions/ with a "use server" file
  - tsconfig.json with strict: true
  - package-lock.json (for npm detection)
- Call `analyzeProject(tempDir)` and verify:
  - framework.name === "next", framework.variant === "next-app-router"
  - structure.rootLayoutPath points to layout.tsx
  - typescript.isTypeScript === true, typescript.strict === true
  - packageManager === "npm"
  - providers array has ThemeProvider
  - components array has the test component
  - toolCandidates array has the server action
- Clean up temp dir in afterAll.
  </action>
  <verify>
  Run `npm test -w cli -- --testPathPattern="project-analysis/index"` and all tests pass.
  Run `npm run check-types -w cli` with no errors.
  Run `npm run lint -w cli` with no errors.
  </verify>
  <done>
  analyzeProject() returns a complete ProjectAnalysis object combining all detection modules. Integration test proves end-to-end flow with a simulated Next.js project. All types and functions are exported from the module index.
  </done>
  </task>

</tasks>

<verification>
- `npm test -w cli -- --testPathPattern="project-analysis"` — ALL project-analysis tests pass (plans 01, 02, 03)
- `npm run check-types -w cli` — no type errors
- `npm run lint -w cli` — no lint errors
- `npm test -w cli` — full CLI test suite passes (no regressions)
</verification>

<success_criteria>

- analyzeProject() produces a complete ProjectAnalysis from a single call
- Tool detection finds server actions, fetch-calling functions, exported async functions
- Integration test verifies full pipeline with simulated Next.js project
- All detection modules are re-exported from index.ts for convenient imports
- Package manager detection reuses existing cli/src/utils/package-manager.ts
- Full CLI test suite passes with no regressions
  </success_criteria>

<output>
After completion, create `.planning/phases/02-codebase-analysis/02-03-SUMMARY.md`
</output>
