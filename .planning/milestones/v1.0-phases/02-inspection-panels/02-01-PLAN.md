---
phase: 02-inspection-panels
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - react-sdk/src/devtools/devtools-protocol.ts
  - react-sdk/src/devtools/devtools-bridge.ts
  - react-sdk/src/devtools/tambo-dev-tools.tsx
  - react-sdk/src/devtools/serialize-snapshot.ts
  - apps/web/devtools-server/types.ts
  - apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts
autonomous: true

must_haves:
  truths:
    - "SDK bridge emits enriched state snapshots containing threads with full messages, streaming state, component/tool schemas, MCP servers, and errors"
    - "Dashboard hook receives and stores snapshots per session ID"
    - "Non-serializable data (ReactElements, functions, Zod validators) is stripped before wire transmission"
    - "Snapshots are debounced (~250ms) to prevent flooding during streaming"
  artifacts:
    - path: "react-sdk/src/devtools/devtools-protocol.ts"
      provides: "Enriched DevToolsStateSnapshot with messages, schemas, MCP, streaming state, errors"
      contains: "messages"
    - path: "react-sdk/src/devtools/serialize-snapshot.ts"
      provides: "Safe serialization stripping ReactElements, functions, Zod schemas -> JSON Schema"
      exports: ["serializeForDevtools"]
    - path: "react-sdk/src/devtools/tambo-dev-tools.tsx"
      provides: "Context extraction and debounced snapshot sending"
      contains: "useStreamState"
    - path: "apps/web/devtools-server/types.ts"
      provides: "Mirror of enriched snapshot types for dashboard side"
      contains: "messages"
    - path: "apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts"
      provides: "Per-session snapshot storage"
      contains: "snapshots"
  key_links:
    - from: "react-sdk/src/devtools/tambo-dev-tools.tsx"
      to: "react-sdk/src/devtools/devtools-bridge.ts"
      via: "bridge.send(snapshot)"
      pattern: "bridge\\.send"
    - from: "react-sdk/src/devtools/tambo-dev-tools.tsx"
      to: "react-sdk/src/devtools/serialize-snapshot.ts"
      via: "serializeForDevtools call"
      pattern: "serializeForDevtools"
    - from: "apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts"
      to: "state_update message"
      via: "case state_update stores snapshot"
      pattern: "state_update.*snapshot"
---

<objective>
Enrich the devtools wire protocol with full thread/message/registry/error data, wire the SDK bridge to extract state from React contexts and emit debounced snapshots, and extend the dashboard hook to store snapshots per session.

Purpose: This is the data pipeline. Without enriched snapshots flowing from SDK to dashboard, no inspection panels can render anything.
Output: SDK sends full state snapshots; dashboard hook stores them; ready for UI consumption.
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-inspection-panels/02-RESEARCH.md

@react-sdk/src/devtools/devtools-protocol.ts
@react-sdk/src/devtools/devtools-bridge.ts
@react-sdk/src/devtools/tambo-dev-tools.tsx
@react-sdk/src/v1/types/thread.ts
@react-sdk/src/v1/types/message.ts
@react-sdk/src/v1/utils/event-accumulator.ts
@react-sdk/src/providers/tambo-registry-provider.tsx
@react-sdk/src/v1/providers/tambo-v1-stream-context.tsx
@apps/web/devtools-server/types.ts
@apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enrich protocol types and create snapshot serializer</name>
  <files>
    react-sdk/src/devtools/devtools-protocol.ts
    react-sdk/src/devtools/serialize-snapshot.ts
    apps/web/devtools-server/types.ts
  </files>
  <action>
    1. **Enrich `DevToolsStateSnapshot` in `react-sdk/src/devtools/devtools-protocol.ts`:**
       - Add to each thread entry: `messages` array with `{ id, role, content: SerializedContent[], createdAt?, metadata? }`, `createdAt` string, `updatedAt` string, `streamingState?: { status, runId?, messageId?, error? }`
       - For `content`, define `SerializedContent` as a simplified union: `{ type: "text", text: string } | { type: "tool_use", id: string, name: string, input: Record<string, unknown> } | { type: "tool_result", toolUseId: string, content: unknown, isError?: boolean } | { type: "component", name: string, props: Record<string, unknown> } | { type: "resource", uri: string, content: unknown }`. This avoids shipping ReactElements or functions.
       - Add to `registry.components[]`: `propsSchema?: Record<string, unknown>` (JSON Schema)
       - Add to `registry.tools[]`: `inputSchema?: Record<string, unknown>`, `outputSchema?: Record<string, unknown>`
       - Add `registry.mcpServers?: { name: string, url: string, status: string }[]`
       - Add top-level `errors?: { type: "streaming" | "tool_call" | "connection", message: string, threadId?: string, timestamp: number }[]`

    2. **Create `react-sdk/src/devtools/serialize-snapshot.ts`:**
       - Export `serializeForDevtools(raw: RawDevtoolsState): Omit<DevToolsStateSnapshot, "type" | "sessionId" | "timestamp">`
       - `RawDevtoolsState` takes the raw SDK state: `{ streamState: StreamState, componentList: ComponentRegistry, toolRegistry: TamboToolRegistry, mcpServerInfos: NormalizedMcpServerInfo[] }`
       - For each thread in `streamState.threadMap`: extract `thread.id`, `thread.name`, `thread.status` (map RunStatus to "idle"|"streaming"|"waiting"), `thread.messages.length`, timestamps from thread, full messages with serialized content, and `streaming` state from ThreadState
       - For content blocks: strip `renderedComponent` from TamboComponentContent (replace with `[ReactElement]`), strip functions, convert remaining to SerializedContent format
       - For component schemas: use a JSON replacer or try-catch JSON.stringify. If schema has `~standard` property (Standard Schema) or is a Zod schema, attempt `JSON.stringify` and fall back to `{ type: "unknown", description: "Schema not serializable" }`. The SDK has `zod-to-json-schema` as an optional peer dep -- only use it if available via dynamic import, otherwise just stringify what's possible.
       - For tool schemas: same approach as component schemas
       - For errors: scan each ThreadState.streaming for `error` field, scan tool_result content blocks for `is_error: true`, collect into top-level errors array
       - Use a safe JSON replacer that converts functions to `"[Function]"`, ReactElements (objects with `$$typeof` Symbol) to `"[ReactElement]"`, `undefined` to `null`, and handles circular references with `"[Circular]"` using a WeakSet

    3. **Mirror enriched types in `apps/web/devtools-server/types.ts`:**
       - Update `StateSnapshotMessage` to match the enriched `DevToolsStateSnapshot` structure (same fields for threads with messages, enriched registry, errors)
       - Keep types independent per Phase 1 decision (no cross-package imports)

  </action>
  <verify>
    Run `npm run check-types` from repo root -- both react-sdk and apps/web must pass with the new/updated types.
  </verify>
  <done>
    Protocol types enriched on both sides. Serializer function exists and handles non-serializable data safely. Type checking passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire SDK bridge to emit snapshots and extend dashboard hook to store them</name>
  <files>
    react-sdk/src/devtools/tambo-dev-tools.tsx
    react-sdk/src/devtools/devtools-bridge.ts
    apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts
  </files>
  <action>
    1. **Update `TamboDevTools` component (`react-sdk/src/devtools/tambo-dev-tools.tsx`):**
       - Import `useStreamState` from `../v1/providers/tambo-v1-stream-context` and `TamboRegistryContext` from `../providers/tambo-registry-provider` (use `useContext` directly, not throwing hooks, so it degrades gracefully)
       - Store the bridge instance in a `useRef` so it persists across renders. Create bridge in useEffect on mount, store in ref, clean up on unmount (current pattern but using ref instead of local variable)
       - Add a second `useEffect` that depends on `streamState`, `registry.componentList`, `registry.toolRegistry`, `registry.mcpServerInfos`. Inside it:
         - Clear any pending timeout via a `useRef<ReturnType<typeof setTimeout>>`
         - Set a new 250ms timeout that calls `serializeForDevtools(...)` and sends via `bridgeRef.current.send({ type: "state_snapshot", sessionId, timestamp: Date.now(), ...serialized })`
         - Return cleanup that clears the timeout
       - Handle `request_snapshot` in the bridge: currently ignored. Add a callback mechanism: `DevToolsBridge` gets an `onRequestSnapshot` callback. When received, immediately send a snapshot (no debounce). Wire this up in TamboDevTools by setting the callback after bridge creation.
       - The sessionId should be stored in a `useRef` (created once via `crypto.randomUUID()`) so it's stable across re-renders

    2. **Update `DevToolsBridge` (`react-sdk/src/devtools/devtools-bridge.ts`):**
       - Add optional `onRequestSnapshot?: () => void` to `DevToolsBridgeOptions`
       - In `handleServerMessage`, when `request_snapshot` is received, call `this.options.onRequestSnapshot?.()` instead of the current no-op comment
       - No other changes needed -- the `send()` method already works for any `DevToolsMessage`

    3. **Extend `useDevtoolsConnection` (`apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts`):**
       - Add `snapshots: Map<string, StateSnapshot>` state (where `StateSnapshot` mirrors the enriched snapshot type from `@/devtools-server/types`)
       - Export `snapshots` in the return type alongside `isConnected`, `clients`, `error`
       - In the `state_update` case of `handleMessage`: extract `message.sessionId` and `message.snapshot`, store in snapshots map via `setSnapshots(prev => new Map(prev).set(sessionId, snapshot))`
       - In the `client_disconnected` case: remove that session's snapshot from the map
       - Add `selectedSessionId` state and `setSelectedSessionId` to the return. Default to first connected client's sessionId. Auto-select when a new client connects and nothing is selected.
       - Export a `requestSnapshot(sessionId: string)` function that sends `{ type: "request_client_snapshot", sessionId }` via the WebSocket

  </action>
  <verify>
    1. `npm run check-types` passes for both react-sdk and apps/web
    2. `npm run lint` passes
    3. `npm test -- --passWithNoTests` passes (no regressions)
  </verify>
  <done>
    SDK bridge extracts state from React contexts and sends debounced enriched snapshots. Dashboard hook stores snapshots per session. Dashboard can request fresh snapshots on demand. request_snapshot server messages trigger immediate snapshot send.
  </done>
</task>

</tasks>

<verification>
1. Type check: `npm run check-types` passes across all workspaces
2. Lint: `npm run lint` passes
3. Tests: `npm test` passes with no regressions
4. Manual: If dev server is running, connect SDK app with `<TamboDevTools />` -- dashboard hook should receive enriched snapshots (visible via console.log in state_update handler if needed for debugging)
</verification>

<success_criteria>

- Enriched DevToolsStateSnapshot type includes full messages, content blocks, schemas, MCP servers, streaming state, and errors
- Serializer safely handles ReactElements, functions, Zod schemas, and circular references
- TamboDevTools extracts state from StreamContext and RegistryContext
- Snapshots debounced at 250ms
- Dashboard hook stores latest snapshot per sessionId
- All types mirrored on dashboard side (no cross-package imports)
- Type checking and linting pass
  </success_criteria>

<output>
After completion, create `.planning/phases/02-inspection-panels/02-01-SUMMARY.md`
</output>
