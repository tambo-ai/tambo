---
phase: 03-streaming-visibility
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/web/app/(authed)/devtools/components/component-stream-panel.tsx
  - apps/web/app/(authed)/devtools/components/tool-call-panel.tsx
  - apps/web/app/(authed)/devtools/page.tsx
autonomous: true

must_haves:
  truths:
    - "Developer can see JSON Patch operations arriving for a streaming component"
    - "Developer can see cumulative props for a component as patches are applied"
    - "Developer can see the streaming lifecycle of a component (started -> streaming -> done)"
    - "Developer can see the full tool call lifecycle: start, accumulated args, end, result"
    - "Developer can see client-side tool execution status"
  artifacts:
    - path: "apps/web/app/(authed)/devtools/components/component-stream-panel.tsx"
      provides: "Component streaming visualizer with patch log and cumulative props"
      exports: ["ComponentStreamPanel"]
    - path: "apps/web/app/(authed)/devtools/components/tool-call-panel.tsx"
      provides: "Tool call lifecycle view grouped by toolCallId"
      exports: ["ToolCallPanel"]
  key_links:
    - from: "component-stream-panel.tsx"
      to: "use-devtools-events.ts or use-devtools-connection.ts"
      via: "filters timeline events to component category"
      pattern: "category.*component"
    - from: "tool-call-panel.tsx"
      to: "use-devtools-events.ts or use-devtools-connection.ts"
      via: "filters timeline events to tool category and groups by toolCallId"
      pattern: "category.*tool"
    - from: "page.tsx"
      to: "component-stream-panel.tsx and tool-call-panel.tsx"
      via: "new Streaming and Tools tabs"
      pattern: "TabsTrigger.*(Streaming|Tools)"
---

<objective>
Build the component streaming visualizer (JSON Patch log + cumulative props) and tool call lifecycle panel (grouped by toolCallId with status tracking).

Purpose: Covers COMP-04/05/06 (component streaming visibility) and STRM-04/05 (tool call lifecycle). These are derived views that filter and group timeline events by category.
Output: Two new tabs in devtools -- "Streaming" for component prop streaming, "Tools" for tool call lifecycle.
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-streaming-visibility/03-RESEARCH.md
@.planning/phases/03-streaming-visibility/03-01-SUMMARY.md

@apps/web/app/(authed)/devtools/page.tsx
@apps/web/app/(authed)/devtools/hooks/use-devtools-events.ts
@apps/web/app/(authed)/devtools/lib/event-categorizer.ts
@apps/web/app/(authed)/devtools/components/json-tree-viewer.tsx
@react-sdk/src/v1/types/event.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Component streaming visualizer panel</name>
  <files>
    apps/web/app/(authed)/devtools/components/component-stream-panel.tsx
  </files>
  <action>
    Create `component-stream-panel.tsx`:

    Props: `events: TimelineEvent[]` (pre-filtered to component category by the page, OR filter internally)

    The panel groups component events by component identity. Tambo custom events include:
    - `tambo.component.props_delta` -- JSON Patch operation (RFC 6902) arriving for a component
    - `tambo.component.started` -- component streaming started
    - `tambo.component.done` -- component streaming finished

    Layout:
    1. **Component list** (left sidebar or top section):
       - Extract unique component IDs from events (look for `payload.componentId` or `payload.name`)
       - Show each component with a status badge: "started" (blue pulse), "streaming" (green pulse), "done" (green static), derived from the latest lifecycle event for that component
       - Click to select a component

    2. **Selected component detail** (main area):
       - **Lifecycle status**: Show current state (started -> streaming -> done) as a horizontal stepper/badge row
       - **Patch log**: Chronological list of `props_delta` events showing the JSON Patch operations (op, path, value). Display using a simple table or list:
         - Timestamp | Op (add/replace/remove) | Path | Value (truncated)
       - **Cumulative props**: Use the snapshot data (from `currentSnapshot.threads[].messages`) as source of truth for current props, NOT by replaying patches (per research: replay is unreliable if patches were missed). Show using existing `JsonTreeViewer`.
       - If cumulative props cannot be derived from snapshot (component not in current snapshot), show the last known patch value with a "may be incomplete" warning.

    3. **Empty state**: "No component streaming events yet. Components stream props via JSON Patch operations during AI responses."

    Important: The panel is a read-only derived view of timeline events. It does NOT maintain separate state -- it filters and groups the events array on each render (events array is already RAF-batched so re-computation is bounded to ~60fps). Use `useMemo` to memoize the grouping.

  </action>
  <verify>
    - `npm run check-types` passes
    - `npm run lint` passes
    - Component renders without errors when given empty events array
    - Component renders without errors when given mock component events
  </verify>
  <done>Component streaming panel shows per-component lifecycle status, patch log with op/path/value, and cumulative props via JsonTreeViewer. COMP-04, COMP-05, COMP-06 satisfied.</done>
</task>

<task type="auto">
  <name>Task 2: Tool call lifecycle panel and page integration</name>
  <files>
    apps/web/app/(authed)/devtools/components/tool-call-panel.tsx
    apps/web/app/(authed)/devtools/page.tsx
  </files>
  <action>
    1. Create `tool-call-panel.tsx`:

       Props: `events: TimelineEvent[]` (all events -- panel filters to tool category internally)

       Group tool events by `toolCallId` (from `payload.toolCallId`). For each tool call, build a lifecycle object:
       ```
       { toolCallId, toolName, status, args, result, events[] }
       ```

       Status derived from latest event:
       - Only `TOOL_CALL_START` seen -> "calling" (orange badge)
       - `TOOL_CALL_ARGS` accumulating -> "calling" (orange badge, show accumulated args)
       - `TOOL_CALL_END` seen -> "args complete" (yellow badge)
       - `tambo.run.awaiting_input` -> "awaiting input" (blue pulse badge)
       - `TOOL_CALL_RESULT` seen -> "complete" (green badge)
       - Any error -> "error" (red badge)

       Layout:
       - **Tool call list**: Scrollable list of tool calls, newest first. Each shows:
         - Tool name (bold)
         - Status badge (colored per above)
         - Timestamp of first event
         - Duration (first event to last event, if available)
       - **Selected tool call detail**: When clicked, expand to show:
         - Full lifecycle timeline (vertical stepper showing each event in order)
         - Accumulated args (via JsonTreeViewer)
         - Result (via JsonTreeViewer, if TOOL_CALL_RESULT received)
         - Client execution status if `tambo.run.awaiting_input` present

       Empty state: "No tool calls yet. Tool calls appear here as the AI invokes tools during responses."

       Use `useMemo` to memoize tool call grouping from events array.

    2. Update `page.tsx`:
       - Import `ComponentStreamPanel` and `ToolCallPanel`
       - Add "Streaming" and "Tools" tabs to the existing Tabs component (order: Inspector, Registry, Timeline, Streaming, Tools)
       - Pass the events from `useDevtoolsEvents` to both panels
       - Both tab contents use the same 600px height container as other tabs
       - Also pass `currentSnapshot` to ComponentStreamPanel if it needs snapshot data for cumulative props

    Note: Plans 02 and 03 both modify `page.tsx`. Since they're in the same wave but independent features, the executor should handle this. Plan 02 adds the Timeline tab, Plan 03 adds Streaming + Tools tabs. If executed sequentially, the second plan will see the first's changes. If parallel, merge is straightforward since they add different tabs.

  </action>
  <verify>
    - `npm run check-types` passes
    - `npm run lint` passes
    - `npm run build -w apps/web` succeeds
    - All 5 tabs visible in devtools page (Inspector, Registry, Timeline, Streaming, Tools)
    - Tool call panel renders with empty state when no tool events
    - Component stream panel renders with empty state when no component events
  </verify>
  <done>Tool call lifecycle panel groups events by toolCallId showing full lifecycle with status badges. Component streaming and tool call panels integrated into devtools page as new tabs. STRM-04, STRM-05 satisfied.</done>
</task>

</tasks>

<verification>
- `npm run check-types` passes across workspace
- `npm run lint` passes across workspace
- `npm test` passes across workspace
- `npm run build -w apps/web` succeeds
- All 5 tabs present in devtools page
- Component streaming panel shows lifecycle + patch log
- Tool call panel shows grouped lifecycle with status badges
</verification>

<success_criteria>
COMP-04: JSON Patch operations visible as they arrive. COMP-05: Cumulative props shown via JsonTreeViewer. COMP-06: Component streaming lifecycle (started/streaming/done) displayed with badges. STRM-04: Full tool call lifecycle visible (start, args, end, result). STRM-05: Client-side tool execution status shown (awaiting input, executing, result).
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming-visibility/03-03-SUMMARY.md`
</output>
