---
phase: 01-websocket-bridge
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/devtools-server/server.ts
  - apps/web/devtools-server/connection-manager.ts
  - apps/web/devtools-server/types.ts
  - apps/web/package.json
  - apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts
  - package.json
  - turbo.json
autonomous: true

must_haves:
  truths:
    - "Running the devtools server opens a WebSocket on ws://localhost:8265"
    - "An SDK client connecting and sending a handshake message is tracked by the connection manager"
    - "A dashboard client connecting receives a client_list of currently connected SDK instances"
    - "When an SDK client disconnects, connected dashboard clients receive a client_disconnected event"
    - "The devtools server starts automatically as part of dev:cloud"
    - "Dead connections are cleaned up via heartbeat ping/pong"
  artifacts:
    - path: "apps/web/devtools-server/server.ts"
      provides: "Standalone WebSocket server entry point on port 8265"
      contains: "WebSocketServer"
    - path: "apps/web/devtools-server/connection-manager.ts"
      provides: "Tracks SDK and dashboard client connections, routes messages between them"
      exports: ["ConnectionManager"]
    - path: "apps/web/devtools-server/types.ts"
      provides: "Server-side protocol type definitions (compatible with SDK protocol)"
      contains: "type SdkMessage"
    - path: "apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts"
      provides: "React hook for dashboard pages to connect to devtools WS server"
      exports: ["useDevtoolsConnection"]
  key_links:
    - from: "apps/web/devtools-server/server.ts"
      to: "apps/web/devtools-server/connection-manager.ts"
      via: "server creates ConnectionManager, delegates message handling"
      pattern: "new ConnectionManager"
    - from: "apps/web/devtools-server/connection-manager.ts"
      to: "apps/web/devtools-server/types.ts"
      via: "uses message type discriminated unions for routing"
      pattern: "SdkMessage|DashboardCommand"
    - from: "apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts"
      to: "ws://localhost:8265"
      via: "WebSocket client connection from dashboard to devtools server"
      pattern: "new WebSocket.*8265"
---

<objective>
Create the standalone WebSocket devtools server and dashboard-side connection hook. The server runs on port 8265, receives SDK client connections with handshake, tracks them via a connection manager, and routes events to connected dashboard clients.

Purpose: This is the server half of the WebSocket bridge. It receives connections from SDK instances (`<TamboDevTools />`) and from dashboard pages, tracks connected clients, and routes messages between them. This plan covers INFRA-02 (dashboard receives/processes events) and the server infrastructure for INFRA-03 (connection status data).

Output: `apps/web/devtools-server/` with standalone WS server, connection manager, and types. Dashboard-side hook for connecting to the server. Updated dev:cloud script to auto-start the server.
</objective>

<execution_context>
@/Users/lachlan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lachlan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-websocket-bridge/01-RESEARCH.md

@apps/web/package.json
@package.json
@turbo.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create devtools server with connection manager</name>
  <files>
    apps/web/devtools-server/types.ts
    apps/web/devtools-server/connection-manager.ts
    apps/web/devtools-server/server.ts
    apps/web/package.json
  </files>
  <action>
**0. Install ws as a direct dependency in apps/web:**
```
npm install ws -w apps/web
npm install --save-dev @types/ws -w apps/web
```
(`ws` is already transitive via openai/jsdom, but making it explicit per research recommendation.)

**1. Create `apps/web/devtools-server/types.ts`:**

Define server-side message types. These are intentionally independent from the SDK types (no cross-package import) -- the wire protocol is JSON, so both sides define compatible types independently.

SDK -> Server messages (`SdkMessage` discriminated union):

- `handshake`: `{ type: "handshake", protocolVersion: number, sdkVersion: string, projectId?: string, sessionId: string }`
- `state_snapshot`: `{ type: "state_snapshot", sessionId: string, timestamp: number, threads: Array<{...}>, registry: {...} }`
- `heartbeat`: `{ type: "heartbeat", sessionId: string, timestamp: number }`

Server -> SDK messages (`ServerToSdkMessage`):

- `handshake_ack`: `{ type: "handshake_ack", sessionId: string, serverVersion: string }`
- `request_snapshot`: `{ type: "request_snapshot" }`

Server -> Dashboard messages (`ServerToDashboardMessage`):

- `client_connected`: `{ type: "client_connected", sessionId: string, sdkVersion: string, projectId?: string, connectedAt: number }`
- `client_disconnected`: `{ type: "client_disconnected", sessionId: string }`
- `state_update`: `{ type: "state_update", sessionId: string, snapshot: object }`
- `client_list`: `{ type: "client_list", clients: Array<{ sessionId: string, sdkVersion: string, projectId?: string, connectedAt: number }> }`

Dashboard -> Server messages (`DashboardCommand`):

- `subscribe_dashboard`: `{ type: "subscribe_dashboard" }` (identifies this connection as a dashboard client)
- `request_client_list`: `{ type: "request_client_list" }`
- `request_client_snapshot`: `{ type: "request_client_snapshot", sessionId: string }`

Also define `ConnectedSdkClient` interface: `{ ws: WebSocket, sessionId: string, sdkVersion: string, projectId?: string, connectedAt: number, isAlive: boolean }`.

Also define `ConnectedDashboardClient` interface: `{ ws: WebSocket, id: string }`.

Export constants: `DEVTOOLS_PORT = 8265`, `HEARTBEAT_INTERVAL = 30_000`, `SERVER_VERSION = "0.1.0"`.

**2. Create `apps/web/devtools-server/connection-manager.ts`:**

Export class `ConnectionManager` with:

Private state:

- `sdkClients: Map<string, ConnectedSdkClient>` (keyed by sessionId)
- `dashboardClients: Map<string, ConnectedDashboardClient>` (keyed by generated id)

Public methods:

- `handleNewConnection(ws: WebSocket): void` -- Registers `message` listener on ws. The first message determines the client type:
  - If `type === "handshake"` -> SDK client. Store in sdkClients, send `handshake_ack`, broadcast `client_connected` to all dashboard clients.
  - If `type === "subscribe_dashboard"` -> Dashboard client. Store in dashboardClients with `crypto.randomUUID()` id, immediately send `client_list` with all current SDK clients.
  - Register `close` handler: if SDK client, remove from map, broadcast `client_disconnected` to dashboards. If dashboard client, remove from map.
  - Register `pong` handler: mark SDK client `isAlive = true`.

- `handleSdkMessage(sessionId: string, message: SdkMessage): void` -- Routes messages:
  - `state_snapshot` -> forward to all dashboard clients as `state_update`
  - `heartbeat` -> update client's `isAlive`

- `broadcastToDashboard(message: ServerToDashboardMessage): void` -- Sends to all connected dashboard clients. Skip clients whose `ws.readyState !== WebSocket.OPEN`.

- `runHeartbeat(): void` -- Iterates sdkClients. If `!isAlive`, terminate and remove. Otherwise set `isAlive = false` and `ws.ping()`.

- `getClientList(): Array<{ sessionId, sdkVersion, projectId, connectedAt }>` -- Returns metadata for all SDK clients.

- `cleanup(): void` -- Close all connections, clear maps.

Keep all JSON parsing inside try/catch. Log parse errors to stderr but do not crash.

**3. Create `apps/web/devtools-server/server.ts`:**

This is the entry point, run with `tsx apps/web/devtools-server/server.ts`.

```typescript
import { WebSocketServer } from "ws";
import { ConnectionManager } from "./connection-manager";
import { DEVTOOLS_PORT, HEARTBEAT_INTERVAL } from "./types";

const manager = new ConnectionManager();
const wss = new WebSocketServer({ port: DEVTOOLS_PORT, host: "localhost" });

wss.on("connection", (ws) => {
  manager.handleNewConnection(ws);
});

const heartbeatInterval = setInterval(() => {
  manager.runHeartbeat();
}, HEARTBEAT_INTERVAL);

wss.on("close", () => {
  clearInterval(heartbeatInterval);
  manager.cleanup();
});

// Graceful shutdown
process.on("SIGTERM", () => {
  clearInterval(heartbeatInterval);
  manager.cleanup();
  wss.close();
});

process.on("SIGINT", () => {
  clearInterval(heartbeatInterval);
  manager.cleanup();
  wss.close();
});

console.log(
  `[DevTools] WebSocket server listening on ws://localhost:${DEVTOOLS_PORT}`,
);
```

**4. Add `dev:devtools` script to `apps/web/package.json`:**

Add to scripts:

```json
"dev:devtools": "tsx watch devtools-server/server.ts"
```

This uses `tsx` (already installed at repo root as devDep) with `watch` mode so the server restarts on file changes during development.

Also add `tsx` to apps/web devDependencies if not already present (check first -- it may be available from the root). Actually, `tsx` is a root devDep. For workspace scripts, it should be accessible. But to be safe and explicit, the server.ts can be run from the root with `npx tsx apps/web/devtools-server/server.ts`. Let's use the simpler approach: add the script to apps/web and rely on the hoisted `tsx`.
</action>
<verify>

1. `npx tsx apps/web/devtools-server/server.ts &` starts without errors and prints the listening message.
2. `echo '{"type":"handshake","protocolVersion":1,"sdkVersion":"1.0.1","sessionId":"test-123"}' | npx wscat -c ws://localhost:8265` receives a handshake_ack response (install wscat temporarily if needed, or use a simple Node.js script to test).
3. Kill the server process.
4. `npm run check-types -w apps/web` passes (or at least the devtools-server files have no type errors -- the server files may not be included in the web app's tsconfig since they're standalone scripts).
   </verify>
   <done>
   Standalone WebSocket server runs on port 8265, accepts SDK handshakes, tracks connections, routes events to dashboard clients, and cleans up dead connections via heartbeat.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Create dashboard connection hook and wire dev:cloud to auto-start server</name>
  <files>
    apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts
    package.json
    turbo.json
  </files>
  <action>
**1. Create `apps/web/app/(authed)/devtools/hooks/use-devtools-connection.ts`:**

A React hook `useDevtoolsConnection` that manages a WebSocket connection from the dashboard to the devtools server.

```typescript
"use client";
```

Interface `DevtoolsClient`:

```typescript
interface DevtoolsClient {
  sessionId: string;
  sdkVersion: string;
  projectId?: string;
  connectedAt: number;
}
```

Interface `UseDevtoolsConnectionReturn`:

```typescript
interface UseDevtoolsConnectionReturn {
  isConnected: boolean;
  clients: DevtoolsClient[];
  error: string | null;
}
```

The hook:

- Takes optional `{ port?: number, host?: string }` options (defaults to `localhost:8265`).
- Uses `useState` for `isConnected`, `clients` array, and `error`.
- Uses `useRef<WebSocket | null>` for the WS instance.
- In `useEffect` (deps: `[host, port]`):
  - Creates a native `WebSocket` (not partysocket -- dashboard is already on localhost, simpler reconnection handled by the hook itself or the user refreshing the page).
  - On open: send `{ type: "subscribe_dashboard" }`, set `isConnected: true`, clear error.
  - On message: parse JSON. Handle `client_list` (set clients), `client_connected` (append to clients), `client_disconnected` (remove from clients by sessionId), `state_update` (ignore for Phase 1, will be used in Phase 2).
  - On close: set `isConnected: false`. Attempt reconnect after 2 seconds via `setTimeout`. Track the timeout in a ref for cleanup.
  - On error: set error message.
  - Cleanup: close WS, clear reconnect timeout.
- Return `{ isConnected, clients, error }`.

Export the hook and the `DevtoolsClient` type.

**2. Update root `package.json` to auto-start devtools server with dev:cloud:**

The cleanest approach: add a turbo task for the devtools server and include it in `dev:cloud`.

Add to `turbo.json` tasks:

```json
"@tambo-ai-cloud/web#dev:devtools": {
  "cache": false,
  "persistent": true
}
```

Update root `package.json` `dev:cloud` script to include the devtools server:

```json
"dev:cloud": "turbo dev --filter=@tambo-ai-cloud/web --filter=@tambo-ai-cloud/api && turbo dev:devtools --filter=@tambo-ai-cloud/web"
```

Wait -- turbo's `&&` doesn't work for persistent tasks (they never "complete"). We need concurrency. Turbo can run multiple tasks in parallel if they're all in the same `turbo` invocation. The better approach is:

Option A: Use turbo's `dependsOn` to start the devtools server as part of the web app's dev. But this is hacky since dev:devtools isn't a prerequisite for dev.

Option B: Run them concurrently. The simplest: update `apps/web/package.json` dev script to run both next dev and the devtools server concurrently. The web app already has `concurrently` available (check first -- react-sdk has it).

Actually, the cleanest option: add a separate turbo task for the devtools server and update the root dev:cloud to include it:

```json
"dev:cloud": "turbo dev dev:devtools --filter=@tambo-ai-cloud/web --filter=@tambo-ai-cloud/api"
```

This tells turbo to run both `dev` and `dev:devtools` tasks across the filtered workspaces. Only `@tambo-ai-cloud/web` has a `dev:devtools` script, so turbo will run it there. The API and web `dev` tasks run as before.

Add the turbo task config:

```json
"@tambo-ai-cloud/web#dev:devtools": {
  "cache": false,
  "persistent": true
}
```

Test this approach. If turbo doesn't support running multiple named tasks this way, fall back to using `concurrently` in apps/web's dev script:

```json
"dev": "concurrently \"next dev -p 8260\" \"tsx watch devtools-server/server.ts\"",
```

(Would require adding `concurrently` to apps/web devDeps.)

Use the turbo approach first (preferred). If it doesn't work, use the concurrently fallback.
</action>
<verify>

1. `npm run dev:cloud` starts the Next.js web app, the NestJS API, AND prints `[DevTools] WebSocket server listening on ws://localhost:8265` in the terminal output.
2. While dev:cloud is running, opening a browser console and running `new WebSocket("ws://localhost:8265")` connects successfully.
3. `npm run check-types -w apps/web` passes.
   </verify>
   <done>
   Dashboard-side hook `useDevtoolsConnection` manages WS connection to devtools server and tracks connected SDK clients. The devtools server auto-starts with `dev:cloud` via turbo task orchestration.
   </done>
   </task>

</tasks>

<verification>
1. `npm run dev:cloud` starts all three processes (web, api, devtools server).
2. DevTools server accepts connections on ws://localhost:8265.
3. A simulated SDK handshake message is acknowledged with handshake_ack.
4. A simulated dashboard subscription receives client_list.
5. `npm run check-types -w apps/web` passes.
6. `npm run lint -w apps/web` passes.
</verification>

<success_criteria>

- Standalone WS server runs on port 8265 and logs startup message
- SDK handshake messages are parsed, acknowledged, and client is tracked
- Dashboard clients receive real-time notifications of SDK client connect/disconnect
- Heartbeat ping/pong cleans up dead connections every 30 seconds
- Server auto-starts with dev:cloud command
- useDevtoolsConnection hook tracks connection state and client list
  </success_criteria>

<output>
After completion, create `.planning/phases/01-websocket-bridge/01-02-SUMMARY.md`
</output>
