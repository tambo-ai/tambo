/**
 * THIS FILE IS AUTO-SYNCED FROM CLI REGISTRY
 *
 * Component: message-input
 * Source: cli/src/registry/message-input/
 *
 * DO NOT EDIT THIS FILE DIRECTLY
 * Make changes in cli/src/registry/message-input/ and run sync script
 */

"use client";

import { cn } from "@/lib/utils";
import { useTamboThreadInput } from "@tambo-ai/react";
import {
  useTamboMcpPrompt,
  useTamboMcpPromptList,
  useTamboMcpResourceList,
} from "@tambo-ai/react/mcp";
import Document from "@tiptap/extension-document";
import Mention from "@tiptap/extension-mention";
import Paragraph from "@tiptap/extension-paragraph";
import Placeholder from "@tiptap/extension-placeholder";
import Text from "@tiptap/extension-text";
import {
  EditorContent,
  Extension,
  ReactRenderer,
  useEditor,
  type Editor,
} from "@tiptap/react";
import type { SuggestionOptions } from "@tiptap/suggestion";
import Suggestion from "@tiptap/suggestion";
import { AtSign, Cuboid, FileText } from "lucide-react";
import * as React from "react";
import { forwardRef, useEffect, useImperativeHandle, useState } from "react";
import tippy, { type Instance as TippyInstance } from "tippy.js";
import "tippy.js/dist/tippy.css";

/**
 * Represents a resource item that appears in the "@" mention dropdown.
 * Resources are referenced by ID/URI and appear as visual mention nodes in the editor.
 */
export interface ResourceItem {
  id: string;
  name: string;
  icon?: React.ReactNode;
  componentData?: unknown;
}

/**
 * Represents a prompt item that appears in the "/" command dropdown.
 * Prompts contain text that gets inserted into the editor.
 */
export interface PromptItem {
  id: string;
  name: string;
  icon?: React.ReactNode;
  /** The actual prompt text to insert into the editor */
  text: string;
}

/**
 * Provider interface for searching resources (for "@" mentions).
 * Empty query string "" should return all available resources.
 */
export interface ResourceProvider {
  /** Search for resources matching the query */
  search(query: string): Promise<ResourceItem[]>;
}

/**
 * Provider interface for searching and fetching prompts (for "/" commands).
 * Empty query string "" should return all available prompts.
 */
export interface PromptProvider {
  /** Search for prompts matching the query */
  search(query: string): Promise<PromptItem[]>;
  /** Get the full prompt details including text by ID */
  get(id: string): Promise<PromptItem>;
}

export interface TextEditorProps {
  value: string;
  onChange: (text: string) => void;
  onKeyDown?: (event: React.KeyboardEvent, editor: Editor) => void;
  placeholder?: string;
  disabled?: boolean;
  className?: string;
  editorRef?: React.MutableRefObject<Editor | null>;
  /** Optional submit handler for Tambo-specific Enter key behavior */
  onSubmit?: (e: React.FormEvent) => Promise<void>;
  /** Provider for resource items (displayed with "@" mentions) */
  resourceProvider?: ResourceProvider;
  /** Provider for prompt items (displayed with "/" commands) */
  promptProvider?: PromptProvider;
  /** Called when a resource is selected from the "@" menu */
  onResourceSelect?: (item: ResourceItem) => void;
  /** Called when a prompt is selected from the "/" menu */
  onPromptSelect?: (item: PromptItem) => void;
}

const dedupeResourceItems = (resourceItems: ResourceItem[]) => {
  const seen = new Set<string>();
  return resourceItems.filter((item) => {
    if (seen.has(item.id)) return false;
    seen.add(item.id);
    return true;
  });
};

const filterResourceItems = (
  resourceItems: ResourceItem[],
  query: string,
): ResourceItem[] => {
  // Empty query returns all items
  if (query === "") return resourceItems;

  const normalizedQuery = query.toLocaleLowerCase();
  return resourceItems.filter((item) =>
    item.name.toLocaleLowerCase().includes(normalizedQuery),
  );
};

const filterPromptItems = (
  promptItems: PromptItem[],
  query: string,
): PromptItem[] => {
  // Empty query returns all items
  if (query === "") return promptItems;

  const normalizedQuery = query.toLocaleLowerCase();
  return promptItems.filter((item) =>
    item.name.toLocaleLowerCase().includes(normalizedQuery),
  );
};

/**
 * Hook to create a combined resource provider that merges MCP resources with an external provider.
 * Returns a stable ResourceProvider that searches both sources.
 */
function useCombinedResourceProvider(
  externalProvider: ResourceProvider | undefined,
): ResourceProvider {
  const { data: mcpResources } = useTamboMcpResourceList();

  return React.useMemo<ResourceProvider>(
    () => ({
      search: async (query: string): Promise<ResourceItem[]> => {
        try {
          // Get MCP resources
          const mcpItems: ResourceItem[] = mcpResources
            ? (
                mcpResources as {
                  resource: { uri: string; name?: string };
                }[]
              ).map((entry) => ({
                id: `mcp-resource:${entry.resource.uri}`,
                name: entry.resource.name ?? entry.resource.uri,
                icon: React.createElement(AtSign, { className: "w-4 h-4" }),
                componentData: { type: "mcp-resource", data: entry },
              }))
            : [];

          // Get external resources
          const externalItems = externalProvider
            ? await externalProvider.search(query)
            : [];

          // Combine and dedupe
          const combined = [...mcpItems, ...externalItems];
          const filtered = filterResourceItems(combined, query);
          return dedupeResourceItems(filtered);
        } catch (error) {
          console.error("Failed to fetch resources", error);
          return [];
        }
      },
    }),
    [mcpResources, externalProvider],
  );
}

/**
 * Hook to create a combined prompt provider that merges MCP prompts with an external provider.
 * Returns a stable PromptProvider that searches both sources and fetches prompt details.
 * Only returns prompts when editor is empty.
 *
 * Note: MCP prompts are marked with a special ID prefix so they can be handled separately
 * via the useTamboMcpPrompt hook (since we can't call hooks inside get()).
 */
function useCombinedPromptProvider(
  externalProvider: PromptProvider | undefined,
): PromptProvider {
  const { data: mcpPrompts } = useTamboMcpPromptList();

  return React.useMemo<PromptProvider>(
    () => ({
      search: async (query: string): Promise<PromptItem[]> => {
        try {
          // Get MCP prompts (mark with mcp-prompt: prefix so we know to handle them specially)
          const mcpItems: PromptItem[] = mcpPrompts
            ? (mcpPrompts as { prompt: { name: string } }[]).map((entry) => ({
                id: `mcp-prompt:${entry.prompt.name}`,
                name: entry.prompt.name,
                icon: React.createElement(FileText, { className: "w-4 h-4" }),
                text: "", // Text will be fetched when selected via useTamboMcpPrompt
              }))
            : [];

          // Get external prompts
          const externalItems = externalProvider
            ? await externalProvider.search(query)
            : [];

          // Combine and filter
          const combined = [...mcpItems, ...externalItems];
          return filterPromptItems(combined, query);
        } catch (error) {
          console.error("Failed to fetch prompts", error);
          return [];
        }
      },
      get: async (id: string): Promise<PromptItem> => {
        // Check if this is an MCP prompt (marked with mcp-prompt: prefix)
        if (id.startsWith("mcp-prompt:")) {
          // Return a placeholder - actual text will be fetched via useTamboMcpPrompt hook
          const promptName = id.replace("mcp-prompt:", "");
          return {
            id,
            name: promptName,
            icon: React.createElement(FileText, { className: "w-4 h-4" }),
            text: "", // Will be populated by MCP hook
          };
        }

        // Delegate to external provider
        if (externalProvider) {
          return await externalProvider.get(id);
        }

        throw new Error(`Prompt not found: ${id}`);
      },
    }),
    [mcpPrompts, externalProvider],
  );
}

/**
 * Ref interface for the resource item list component.
 * Allows parent components to handle keyboard events.
 */
interface ResourceItemListRef {
  onKeyDown: (props: { event: KeyboardEvent }) => boolean;
}

/**
 * Dropdown component that displays resource items.
 *
 * When the user types "@" in the editor, this component renders a list
 * of resource items with keyboard navigation (arrow keys, Enter, Escape).
 *
 */
const ResourceItemList = forwardRef<
  ResourceItemListRef,
  { items: ResourceItem[]; command: (item: ResourceItem) => void }
>(({ items, command }, ref) => {
  const [selectedIndex, setSelectedIndex] = useState(0);

  // Reset selection when items change
  useEffect(() => setSelectedIndex(0), [items]);

  const navigate = (delta: number) =>
    setSelectedIndex((i) => (i + delta + items.length) % items.length);

  // Expose keyboard handler to parent
  useImperativeHandle(ref, () => ({
    onKeyDown: ({ event }) => {
      const handlers: Record<string, () => void> = {
        ArrowUp: () => navigate(-1),
        ArrowDown: () => navigate(1),
        Enter: () => items[selectedIndex] && command(items[selectedIndex]),
      };
      const handler = handlers[event.key];
      if (handler) {
        handler();
        return true;
      }
      return false;
    },
  }));

  if (items.length === 0) {
    return (
      <div className="px-3 py-2 text-sm text-muted-foreground">
        No results found
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-0.5 p-1">
      {items.map((item, index) => (
        <button
          key={item.id}
          type="button"
          className={cn(
            "flex items-center gap-2 px-3 py-2 text-sm rounded-md text-left",
            "hover:bg-accent hover:text-accent-foreground transition-colors",
            index === selectedIndex && "bg-accent text-accent-foreground",
          )}
          onClick={() => command(item)}
        >
          {item.icon ?? <Cuboid className="w-4 h-4 flex-shrink-0" />}
          <span className="truncate">{item.name}</span>
        </button>
      ))}
    </div>
  );
});
ResourceItemList.displayName = "ResourceItemList";

/**
 * Checks if a mention with the given label already exists in the editor.
 * Used to prevent duplicate mentions when inserting via @ command or EditableHint.
 *
 * @param editor - The TipTap editor instance
 * @param label - The mention label to check for
 * @returns true if a mention with the given label exists, false otherwise
 */
export function hasExistingMention(editor: Editor, label: string): boolean {
  let hasMention = false;
  editor.state.doc.descendants((node) => {
    if (node.type.name === "mention") {
      const mentionLabel = node.attrs.label as string;
      if (mentionLabel === label) {
        hasMention = true;
        return false; // Stop traversing
      }
    }
    return true;
  });
  return hasMention;
}

/**
 * Creates a popup handler for the resource item dropdown using tippy.js.
 */
function createResourceItemPopup() {
  let itemListComponent: ReactRenderer<ResourceItemListRef> | undefined;
  let tippyPopup: TippyInstance | undefined;

  return {
    /**
     * Called when the user starts typing "@" and resource items should appear.
     * Creates the React component and tippy popup.
     */
    onStart(props: {
      items: ResourceItem[];
      command: (item: ResourceItem) => void;
      editor: Editor;
      clientRect?: (() => DOMRect | null) | null;
    }) {
      itemListComponent = new ReactRenderer(ResourceItemList, {
        props: { items: props.items, command: props.command },
        editor: props.editor,
      });

      if (!props.clientRect) return;

      tippyPopup = tippy("body", {
        getReferenceClientRect: () => props.clientRect?.() ?? new DOMRect(),
        appendTo: () => document.body,
        content: itemListComponent.element,
        showOnCreate: true,
        interactive: true,
        trigger: "manual",
        placement: "bottom-start",
        maxWidth: "24rem",
        theme: "light-border",
      })[0];
    },

    /**
     * Called when resource items change (user continues typing after "@").
     * Updates the resource item list and repositions the popup.
     */
    onUpdate(props: {
      items: ResourceItem[];
      command: (item: ResourceItem) => void;
      clientRect?: (() => DOMRect | null) | null;
    }) {
      itemListComponent?.updateProps({
        items: props.items,
        command: props.command,
      });
      if (props.clientRect && tippyPopup) {
        tippyPopup.setProps({
          getReferenceClientRect: () => props.clientRect?.() ?? new DOMRect(),
        });
      }
    },

    /**
     * Handles keyboard events in the resource item dropdown.
     * - Escape: closes the popup
     * - Arrow keys/Enter: delegated to the resource item list component
     */
    onKeyDown({ event }: { event: KeyboardEvent }) {
      if (event.key === "Escape") {
        tippyPopup?.hide();
        return true;
      }
      const handled = itemListComponent?.ref?.onKeyDown({ event }) ?? false;
      if (handled) event.preventDefault();
      return handled;
    },

    /**
     * Called when the resource item popup should be closed.
     * Cleans up the React component and tippy popup.
     */
    onExit() {
      tippyPopup?.destroy();
      itemListComponent?.destroy();
    },
  };
}

/**
 * Creates the resource mention configuration for TipTap Mention extension.
 * Used for "@" mentions that insert visual mention nodes in the editor.
 */
function createResourceMentionConfig(
  provider: ResourceProvider,
  onSelect: (item: ResourceItem) => void,
  isMenuOpenRef: React.MutableRefObject<boolean>,
): Omit<SuggestionOptions, "editor"> {
  return {
    char: "@",
    items: async ({ query }) => {
      try {
        return await provider.search(query);
      } catch (error) {
        console.error("Failed to fetch resources", error);
        return [];
      }
    },

    render: () => {
      const popupHandlers = createResourceItemPopup();

      const createWrapCommand =
        (editor: Editor) =>
        (tiptapCommand: (attrs: { id: string; label: string }) => void) =>
        (item: ResourceItem) => {
          // Check if mention already exists in the editor
          if (hasExistingMention(editor, item.name)) {
            return;
          }

          // Insert the mention node
          tiptapCommand({ id: item.id, label: item.name });
          // Call selection handler
          onSelect(item);
        };

      return {
        onStart: (props) => {
          if (props.items.length === 0) {
            isMenuOpenRef.current = false;
            return;
          }
          isMenuOpenRef.current = true;
          popupHandlers.onStart({
            items: props.items,
            editor: props.editor,
            clientRect: props.clientRect,
            command: createWrapCommand(props.editor)(props.command),
          });
        },
        onUpdate: (props) => {
          if (props.items.length === 0) {
            popupHandlers.onExit();
            isMenuOpenRef.current = false;
            return;
          }
          popupHandlers.onUpdate({
            items: props.items,
            clientRect: props.clientRect,
            command: createWrapCommand(props.editor)(props.command),
          });
        },
        onKeyDown: popupHandlers.onKeyDown,
        onExit: () => {
          setTimeout(() => {
            isMenuOpenRef.current = false;
          }, 100);
          popupHandlers.onExit();
        },
      };
    },
  };
}

/**
 * Dropdown component for displaying prompt items.
 * Similar to ResourceItemList but for PromptItem type.
 */
const PromptItemList = forwardRef<
  ResourceItemListRef,
  { items: PromptItem[]; command: (item: PromptItem) => void }
>(({ items, command }, ref) => {
  const [selectedIndex, setSelectedIndex] = useState(0);

  useEffect(() => setSelectedIndex(0), [items]);

  const navigate = (delta: number) =>
    setSelectedIndex((i) => (i + delta + items.length) % items.length);

  useImperativeHandle(ref, () => ({
    onKeyDown: ({ event }) => {
      const handlers: Record<string, () => void> = {
        ArrowUp: () => navigate(-1),
        ArrowDown: () => navigate(1),
        Enter: () => items[selectedIndex] && command(items[selectedIndex]),
      };
      const handler = handlers[event.key];
      if (handler) {
        handler();
        return true;
      }
      return false;
    },
  }));

  if (items.length === 0) {
    return (
      <div className="px-3 py-2 text-sm text-muted-foreground">
        No prompts found
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-0.5 p-1">
      {items.map((item, index) => (
        <button
          key={item.id}
          type="button"
          className={cn(
            "flex items-center gap-2 px-3 py-2 text-sm rounded-md text-left",
            "hover:bg-accent hover:text-accent-foreground transition-colors",
            index === selectedIndex && "bg-accent text-accent-foreground",
          )}
          onClick={() => command(item)}
        >
          {item.icon ?? <FileText className="w-4 h-4 flex-shrink-0" />}
          <span className="truncate">{item.name}</span>
        </button>
      ))}
    </div>
  );
});
PromptItemList.displayName = "PromptItemList";

/**
 * Creates a popup handler for the prompt item dropdown.
 */
function createPromptItemPopup() {
  let itemListComponent: ReactRenderer<ResourceItemListRef> | undefined;
  let tippyPopup: TippyInstance | undefined;

  return {
    onStart(props: {
      items: PromptItem[];
      command: (item: PromptItem) => void;
      editor: Editor;
      clientRect?: (() => DOMRect | null) | null;
    }) {
      itemListComponent = new ReactRenderer(PromptItemList, {
        props: { items: props.items, command: props.command },
        editor: props.editor,
      });

      if (!props.clientRect) return;

      tippyPopup = tippy("body", {
        getReferenceClientRect: () => props.clientRect?.() ?? new DOMRect(),
        appendTo: () => document.body,
        content: itemListComponent.element,
        showOnCreate: true,
        interactive: true,
        trigger: "manual",
        placement: "bottom-start",
        maxWidth: "24rem",
        theme: "light-border",
      })[0];
    },
    onUpdate(props: {
      items: PromptItem[];
      command: (item: PromptItem) => void;
      clientRect?: (() => DOMRect | null) | null;
    }) {
      itemListComponent?.updateProps({
        items: props.items,
        command: props.command,
      });
      if (props.clientRect && tippyPopup) {
        tippyPopup.setProps({
          getReferenceClientRect: () => props.clientRect?.() ?? new DOMRect(),
        });
      }
    },
    onKeyDown({ event }: { event: KeyboardEvent }) {
      if (event.key === "Escape") {
        tippyPopup?.hide();
        return true;
      }
      const handled = itemListComponent?.ref?.onKeyDown({ event }) ?? false;
      if (handled) event.preventDefault();
      return handled;
    },
    onExit() {
      tippyPopup?.destroy();
      itemListComponent?.destroy();
    },
  };
}

/**
 * Creates a custom TipTap extension for prompt commands using the Suggestion plugin.
 * Unlike Mention, this doesn't create special nodes - it just triggers text insertion.
 */
function createPromptCommandExtension(
  provider: PromptProvider,
  onSelect: (item: PromptItem) => void,
  isMenuOpenRef: React.MutableRefObject<boolean>,
) {
  return Extension.create({
    name: "promptCommand",

    addProseMirrorPlugins() {
      return [
        Suggestion({
          editor: this.editor,
          char: "/",
          items: async ({ query, editor }) => {
            try {
              // Only show prompts when editor is empty (except for the "/" char)
              const editorValue = editor.getText().replace("/", "").trim();
              if (editorValue.length > 0) {
                return [];
              }
              return await provider.search(query);
            } catch (error) {
              console.error("Failed to fetch prompts", error);
              return [];
            }
          },
          render: () => {
            const popupHandlers = createPromptItemPopup();

            return {
              onStart: (props) => {
                if (props.items.length === 0) {
                  isMenuOpenRef.current = false;
                  return;
                }
                isMenuOpenRef.current = true;
                popupHandlers.onStart({
                  items: props.items,
                  editor: props.editor,
                  clientRect: props.clientRect,
                  command: (item: PromptItem) => {
                    // Delete the "/" trigger character and any typed text
                    props.editor.commands.deleteRange({
                      from: props.range.from,
                      to: props.range.to,
                    });
                    // Call selection handler which will insert the prompt text
                    onSelect(item);
                  },
                });
              },
              onUpdate: (props) => {
                if (props.items.length === 0) {
                  popupHandlers.onExit();
                  isMenuOpenRef.current = false;
                  return;
                }
                popupHandlers.onUpdate({
                  items: props.items,
                  clientRect: props.clientRect,
                  command: (item: PromptItem) => {
                    props.editor.commands.deleteRange({
                      from: props.range.from,
                      to: props.range.to,
                    });
                    onSelect(item);
                  },
                });
              },
              onKeyDown: popupHandlers.onKeyDown,
              onExit: () => {
                setTimeout(() => {
                  isMenuOpenRef.current = false;
                }, 100);
                popupHandlers.onExit();
              },
            };
          },
        }),
      ];
    },
  });
}

/**
 * Custom text extraction that serializes mention nodes with their ID (resource URI)
 * instead of their label. This is needed for message submission.
 */
function getTextWithResourceURIs(editor: Editor | null): string {
  if (!editor) return "";

  let text = "";
  editor.state.doc.descendants((node) => {
    if (node.type.name === "mention") {
      // Use ID for mentions (full resource URI)
      text += `@${node.attrs.id ?? node.attrs.label ?? ""}`;
    } else if (node.isText) {
      text += node.text;
    }
    return true;
  });

  return text;
}

/**
 * Text editor component with resource ("@") and prompt ("/") support.
 */
export const TextEditor = React.forwardRef<HTMLDivElement, TextEditorProps>(
  (
    {
      value,
      onChange,
      onKeyDown,
      placeholder = "What do you want to do?",
      disabled = false,
      className,
      editorRef,
      onSubmit,
      resourceProvider,
      promptProvider,
      onResourceSelect,
      onPromptSelect,
    },
    ref,
  ) => {
    // Use Tambo-specific hooks if onSubmit is provided
    const tamboThreadInput = onSubmit ? useTamboThreadInput() : null;

    // Get combined providers (MCP + external)
    const combinedResourceProvider =
      useCombinedResourceProvider(resourceProvider);
    const combinedPromptProvider = useCombinedPromptProvider(promptProvider);

    // State for MCP prompt fetching (since we can't call hooks inside get())
    const [selectedMcpPromptName, setSelectedMcpPromptName] = React.useState<
      string | null
    >(null);
    const { data: selectedMcpPromptData } = useTamboMcpPrompt(
      selectedMcpPromptName ?? "",
    );

    // Handle MCP prompt insertion when data is fetched
    React.useEffect(() => {
      if (selectedMcpPromptData && selectedMcpPromptName) {
        const promptMessages = (
          selectedMcpPromptData as { messages?: unknown[] }
        )?.messages;
        if (promptMessages) {
          const promptText = promptMessages
            .map((msg: unknown) => {
              const typedMsg = msg as {
                content?: { type?: string; text?: string };
              };
              if (typedMsg.content?.type === "text") {
                return typedMsg.content.text;
              }
              return "";
            })
            .filter(Boolean)
            .join("\n");

          const editor = editorRef?.current;
          if (editor) {
            editor.commands.setContent(promptText);
            onChange(getTextWithResourceURIs(editor));
            editor.commands.focus("end");
          }

          // Call onPromptSelect if provided
          if (onPromptSelect) {
            onPromptSelect({
              id: `mcp-prompt:${selectedMcpPromptName}`,
              name: selectedMcpPromptName,
              text: promptText,
              icon: React.createElement(FileText, { className: "w-4 h-4" }),
            });
          }
        }
        setSelectedMcpPromptName(null);
      }
    }, [
      selectedMcpPromptData,
      selectedMcpPromptName,
      editorRef,
      onChange,
      onPromptSelect,
    ]);

    // Separate refs for tracking "@" and "/" menu states
    const resourceMenuOpenRef = React.useRef<boolean>(false);
    const promptMenuOpenRef = React.useRef<boolean>(false);

    // Handle resource selection
    const handleResourceSelect = React.useCallback(
      (item: ResourceItem) => {
        if (onResourceSelect) {
          onResourceSelect(item);
        }
      },
      [onResourceSelect],
    );

    // Handle prompt selection
    const handlePromptSelect = React.useCallback(
      async (item: PromptItem) => {
        // Check if this is an MCP prompt
        if (item.id.startsWith("mcp-prompt:")) {
          const promptName = item.id.replace("mcp-prompt:", "");
          setSelectedMcpPromptName(promptName);
        } else {
          // External prompt - fetch and insert the text
          try {
            const fullPrompt = await combinedPromptProvider.get(item.id);
            const editor = editorRef?.current;
            if (editor) {
              editor.commands.setContent(fullPrompt.text);
              onChange(getTextWithResourceURIs(editor));
              editor.commands.focus("end");
            }
            if (onPromptSelect) {
              onPromptSelect(fullPrompt);
            }
          } catch (error) {
            console.error("Failed to fetch prompt", error);
          }
        }
      },
      [combinedPromptProvider, editorRef, onChange, onPromptSelect],
    );

    // Handle Enter key to submit message when onSubmit is provided
    const handleKeyDown = React.useCallback(
      (e: React.KeyboardEvent, editor: Editor) => {
        // Handle Tambo-specific Enter key behavior
        if (onSubmit && e.key === "Enter" && !e.shiftKey && value.trim()) {
          e.preventDefault();
          void onSubmit(e as React.FormEvent);
          return;
        }

        // Delegate to provided onKeyDown handler
        if (onKeyDown) {
          onKeyDown(e, editor);
        }
      },
      [onSubmit, value, onKeyDown],
    );

    const editor = useEditor({
      immediatelyRender: false,
      extensions: [
        Document,
        Paragraph,
        Text,
        Placeholder.configure({ placeholder }),
        // Always register the "@" mention extension for resources
        // Visual display uses label, but getTextWithResourceURIs() will use ID
        Mention.configure({
          HTMLAttributes: { class: "mention resource" },
          suggestion: createResourceMentionConfig(
            combinedResourceProvider,
            handleResourceSelect,
            resourceMenuOpenRef,
          ),
          renderLabel: ({ node }) => `@${(node.attrs.label as string) ?? ""}`,
        }),
        // Always register the "/" command extension for prompts
        createPromptCommandExtension(
          combinedPromptProvider,
          handlePromptSelect,
          promptMenuOpenRef,
        ),
      ],
      content: value,
      editable: !disabled,
      onUpdate: ({ editor }) => onChange(getTextWithResourceURIs(editor)),
      editorProps: {
        attributes: {
          class: cn(
            "tiptap",
            "prose prose-sm max-w-none focus:outline-none",
            "p-3 rounded-t-lg bg-transparent text-sm leading-relaxed",
            "min-h-[82px] max-h-[40vh] overflow-y-auto",
            "break-words whitespace-pre-wrap",
            className,
          ),
        },
        handlePaste: (_view, event) => {
          if (!onSubmit || !tamboThreadInput) {
            return false;
          }

          const items = Array.from(event.clipboardData?.items ?? []);
          const imageItems = items.filter((item) =>
            item.type.startsWith("image/"),
          );

          // If there are no images, let TipTap handle the paste normally
          if (imageItems.length === 0) {
            return false;
          }

          const text = event.clipboardData?.getData("text/plain") ?? "";
          const hasText = text.length > 0;

          // Only prevent default when it's an image-only paste so users can still
          // paste mixed text + images and keep the text in the editor
          if (!hasText) {
            event.preventDefault();
          }

          void (async () => {
            if (!tamboThreadInput) return;

            for (const item of imageItems) {
              const file = item.getAsFile();
              if (!file) continue;
              try {
                file[IS_PASTED_IMAGE] = true;
                await tamboThreadInput.addImage(file);
              } catch (error) {
                console.error("Failed to add pasted image:", error);
              }
            }
          })();

          // For pure image pastes we've already prevented the default and
          // signal that the event was handled. For mixed text+image pastes,
          // return false so TipTap can still process the text payload.
          return !hasText;
        },
        handleKeyDown: (view, event) => {
          // Check if any menu is open ("@" or "/")
          const anyMenuOpen =
            resourceMenuOpenRef.current || promptMenuOpenRef.current;

          // Prevent Enter from submitting form when selecting from any menu
          if (event.key === "Enter" && !event.shiftKey && anyMenuOpen) {
            event.preventDefault();
            event.stopPropagation();
            return false;
          }

          // Delegate to handleKeyDown (which handles both Tambo-specific and custom handlers)
          if (editor) {
            const reactEvent = event as unknown as React.KeyboardEvent;
            handleKeyDown(reactEvent, editor);
            return reactEvent.defaultPrevented;
          }
          return false;
        },
      },
    });

    // Sync external value changes and disabled state with editor
    React.useEffect(() => {
      if (!editor) return;
      const currentText = getTextWithResourceURIs(editor);
      if (value !== currentText) {
        editor.commands.setContent(value);
      }
      editor.setEditable(!disabled);
      if (editorRef) {
        editorRef.current = editor;
      }
    }, [editor, value, disabled, editorRef]);

    return (
      <div ref={ref} className="w-full">
        <EditorContent editor={editor} />
      </div>
    );
  },
);

TextEditor.displayName = "TextEditor";

/**
 * Symbol for marking pasted images.
 * Using Symbol.for to create a global symbol that can be accessed across modules.
 * @internal
 */
const IS_PASTED_IMAGE = Symbol.for("tambo-is-pasted-image");

/**
 * Extend the File interface to include the IS_PASTED_IMAGE property.
 * This is a type-safe way to mark pasted images without using a broad index signature.
 */
declare global {
  interface File {
    [IS_PASTED_IMAGE]?: boolean;
  }
}
