/**
 * THIS FILE IS AUTO-SYNCED FROM CLI REGISTRY
 *
 * Component: edit-with-tambo
 * Source: cli/src/registry/edit-with-tambo/
 *
 * DO NOT EDIT THIS FILE DIRECTLY
 * Make changes in cli/src/registry/edit-with-tambo/ and run sync script
 */

"use client";

import { MessageGenerationStage } from "@/components/tambo/message-generation-stage";
import { cn } from "@/lib/utils";
import { useTambo, useTamboInteractableComponent } from "@tambo-ai/react";
import type { Editor } from "@tiptap/react";
import { Bot, ChevronDown, X, XCircle } from "lucide-react";
import * as React from "react";
import { useCallback, useEffect, useRef, useState } from "react";
import { createPortal } from "react-dom";

export interface EditWithTamboProps {
  /** Custom icon component */
  icon?: React.ReactNode;
  /** Custom tooltip text */
  tooltip?: string;
  /** Description for tooltip. Falls back to interactable component description if not provided */
  description?: string;
  /** Optional className for the button */
  className?: string;
  /** Optional callback to open the thread panel/chat interface */
  onOpenThread?: () => void;
  /**
   * Optional TipTap editor ref for inserting text when using "Send in Thread"
   *
   * NOTE: This implementation uses simple text insertion (setContent) to remain
   * portable across different editor setups. It does NOT use TipTap Mention nodes
   * or context attachments. If you need those features, implement them in your
   * own wrapper or see apps/web/components/ui/tambo/edit-with-tambo.tsx for reference.
   */
  editorRef?: React.MutableRefObject<Editor | null>;
}

/**
 * Inline "Edit with Tambo" button and floating popover for interactable components.
 * When clicked, opens a floating popover with a prompt input. Sends messages to Tambo
 * with the interactable component in context and displays only the latest reply.
 *
 * Must be used within a component wrapped with `withInteractable`.
 *
 * @example
 * ```tsx
 * const MyInteractableForm = withInteractable(MyForm, {
 *   componentName: "MyForm",
 *   description: "A form component",
 * });
 *
 * function MyForm() {
 *   return (
 *     <div>
 *       <EditWithTambo />
 *     </div>
 *   );
 * }
 * ```
 */

export function EditWithTambo({
  icon,
  tooltip = "Edit with tambo",
  description,
  className,
  onOpenThread,
  editorRef,
}: EditWithTamboProps) {
  const component = useTamboInteractableComponent();
  const { sendThreadMessage, isIdle } = useTambo();

  const [prompt, setPrompt] = useState("");
  const [isPending, setIsPending] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [isOpen, setIsOpen] = useState(false);
  const [showPopover, setShowPopover] = useState(false);
  const [popoverPosition, setPopoverPosition] = useState({ top: 0, left: 0 });
  const [sendMode, setSendMode] = useState<"send" | "thread">("send");

  const buttonRef = useRef<HTMLButtonElement>(null);
  const popoverRef = useRef<HTMLDivElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const wasGeneratingRef = useRef(false);

  // If no component, the current component is not an interactable - don't render.
  if (!component) {
    return null;
  }

  const isGenerating = !isIdle;

  // Update popover position based on button position
  const updatePosition = useCallback(() => {
    if (buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect();
      // getBoundingClientRect() gives viewport coordinates, which already account for
      // all scroll containers. We only need to add window scroll to get document coordinates
      setPopoverPosition({
        top: rect.bottom + window.scrollY + 8, // 8px spacing below button
        left: rect.left + window.scrollX,
      });
    }
  }, []);

  // Update position immediately when opening
  useEffect(() => {
    if (isOpen || showPopover) {
      updatePosition();
    }
  }, [isOpen, showPopover, updatePosition]);

  // Update position on scroll and resize
  useEffect(() => {
    if (!isOpen && !showPopover) return;

    // Use requestAnimationFrame for smoother updates
    let rafId: number;
    const handleUpdate = () => {
      if (rafId) {
        cancelAnimationFrame(rafId);
      }
      rafId = requestAnimationFrame(() => {
        updatePosition();
      });
    };

    // Listen to scroll on window and all scrollable parents (capture phase)
    // This catches scroll events from any scrollable container
    window.addEventListener("scroll", handleUpdate, true);
    window.addEventListener("resize", handleUpdate);

    return () => {
      if (rafId) {
        cancelAnimationFrame(rafId);
      }
      window.removeEventListener("scroll", handleUpdate, true);
      window.removeEventListener("resize", handleUpdate);
    };
  }, [isOpen, showPopover, updatePosition]);

  // Focus textarea when popover opens
  useEffect(() => {
    if (isOpen && textareaRef.current) {
      setTimeout(() => {
        textareaRef.current?.focus();
      }, 100);
    }
  }, [isOpen]);

  // Handle click outside to close
  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as Node;

      // Don't close if clicking inside popover, button, or dropdown menu (rendered in portal)
      if (
        popoverRef.current?.contains(target) ||
        buttonRef.current?.contains(target) ||
        (target as Element).closest('[role="menu"]')
      ) {
        return;
      }

      setIsOpen(false);
      setPrompt("");
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [isOpen, setIsOpen, setPrompt]);

  // Handle ESC key to close
  useEffect(() => {
    if (!isOpen) return;

    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        setIsOpen(false);
        setPrompt("");
      }
    };

    document.addEventListener("keydown", handleEscape);
    return () => document.removeEventListener("keydown", handleEscape);
  }, [isOpen, setIsOpen, setPrompt]);

  // Close modal when generation completes
  useEffect(() => {
    if (isGenerating) {
      wasGeneratingRef.current = true;
    } else if (wasGeneratingRef.current && !isPending) {
      // Generation just completed - close the modal
      wasGeneratingRef.current = false;
      setIsOpen(false);
      setPrompt("");
    }
  }, [isGenerating, isPending]);

  const handleMouseEnter = useCallback(() => {
    updatePosition();
    setShowPopover(true);
  }, [updatePosition]);

  const handleButtonClick = useCallback(() => {
    setIsOpen(!isOpen);
    if (!isOpen) {
      setShowPopover(true);
    }
  }, [isOpen, setIsOpen]);

  const handleSend = useCallback(async () => {
    if (!prompt.trim() || isPending) {
      return;
    }

    setIsPending(true);
    setError(null);
    setIsOpen(true);

    try {
      // Send the message with the interactable component in context
      await sendThreadMessage(prompt.trim(), {
        streamResponse: true,
        additionalContext: {
          inlineEdit: {
            componentId: component.id,
            componentName: component.componentName,
            description: component.description,
            instruction:
              "The user wants to edit this specific component inline. Please update the component's props to fulfill the user's request.",
          },
        },
      });

      // Clear the prompt after successful send
      setPrompt("");
    } catch (err) {
      const error =
        err instanceof Error ? err : new Error("Failed to send message");
      setError(error);
    } finally {
      setIsPending(false);
    }
  }, [prompt, isPending, component, sendThreadMessage]);

  const handleSendInThread = useCallback(() => {
    if (!prompt.trim()) {
      return;
    }

    // Save the message before clearing
    const messageToInsert = prompt.trim();

    // NOTE: This registry version uses simple text insertion for portability.
    // It does NOT use TipTap Mention nodes or context attachments to avoid
    // dependencies on specific editor configurations. Users can implement
    // their own context system if needed.

    // Open the thread panel if callback provided
    if (onOpenThread) {
      onOpenThread();
    }

    // Clear the prompt and close the modal
    setPrompt("");
    setIsOpen(false);

    // Insert text into the editor if editorRef is provided
    if (editorRef?.current) {
      setTimeout(() => {
        const editor = editorRef.current;
        if (editor) {
          // Set the content of the editor
          editor.commands.setContent(messageToInsert);
          editor.commands.focus("end");
        }
      }, 150); // Wait for panel animation to complete
    }
  }, [prompt, onOpenThread, editorRef]);

  const handleMainAction = useCallback(() => {
    if (sendMode === "thread") {
      handleSendInThread();
    } else {
      void handleSend();
    }
  }, [sendMode, handleSendInThread, handleSend]);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        handleMainAction();
      }
    },
    [handleMainAction],
  );

  return (
    <>
      <span className="inline-flex items-center">
        <button
          ref={buttonRef}
          type="button"
          onClick={handleButtonClick}
          onMouseEnter={handleMouseEnter}
          onMouseLeave={() => setShowPopover(false)}
          className={cn(
            "inline-flex items-center justify-center ml-2 p-1 rounded-md",
            "text-muted-foreground/60 hover:text-primary",
            "hover:bg-accent transition-colors duration-200",
            "cursor-pointer",
            isOpen && "text-primary bg-accent",
            className,
          )}
          aria-label={tooltip}
        >
          {icon ?? <Bot className="h-3.5 w-3.5" />}
        </button>
      </span>

      {/* Hover tooltip - rendered in portal */}
      {showPopover &&
        !isOpen &&
        buttonRef.current &&
        typeof document !== "undefined" &&
        createPortal(
          <div
            className={cn(
              "absolute z-9999",
              "px-3 py-2 text-sm rounded-lg whitespace-nowrap",
              "bg-popover text-popover-foreground border shadow-md",
              "animate-in fade-in-0 zoom-in-95 duration-200",
              "pointer-events-none",
            )}
            style={{
              top: `${popoverPosition.top}px`,
              left: `${popoverPosition.left}px`,
            }}
          >
            <p className="font-medium">{tooltip}</p>
            <p className="text-xs text-muted-foreground mt-1">
              {description ?? component.description}
            </p>
          </div>,
          document.body,
        )}

      {/* Floating popover - rendered in portal */}
      {isOpen &&
        typeof document !== "undefined" &&
        createPortal(
          <div
            ref={popoverRef}
            className={cn(
              "absolute z-9999",
              "w-[450px] max-w-[calc(100vw-2rem)]",
              "bg-popover text-popover-foreground border shadow-lg rounded-lg",
              "animate-in fade-in-0 zoom-in-95 duration-200",
            )}
            style={{
              top: `${popoverPosition.top}px`,
              left: `${popoverPosition.left}px`,
            }}
          >
            <div className="p-4 space-y-4">
              {/* Header */}
              <div className="flex items-center justify-between gap-4">
                <div className="min-w-0 flex-1">
                  <p className="font-medium text-sm">{tooltip}</p>
                  <p className="text-xs text-muted-foreground mt-0.5">
                    {component.componentName}
                  </p>
                </div>
                <button
                  type="button"
                  onClick={() => {
                    setIsOpen(false);
                    setPrompt("");
                  }}
                  className="p-1 rounded-md hover:bg-accent text-muted-foreground hover:text-foreground shrink-0"
                  aria-label="Close"
                >
                  <X className="h-4 w-4" />
                </button>
              </div>

              {/* Prompt input */}
              <div className="space-y-3">
                <textarea
                  ref={textareaRef}
                  value={prompt}
                  onChange={(e) => setPrompt(e.target.value)}
                  onKeyDown={handleKeyDown}
                  placeholder="Describe what you want to change..."
                  className={cn(
                    "w-full min-h-[80px] px-3 py-2 rounded-md",
                    "bg-background border border-input",
                    "text-sm placeholder:text-muted-foreground",
                    "resize-none focus:outline-none focus:ring-2 focus:ring-ring",
                    "disabled:opacity-50 disabled:cursor-not-allowed",
                  )}
                  disabled={isPending}
                />
                <div className="flex items-center justify-between">
                  {/* Helper text or generation status */}
                  {isGenerating && onOpenThread ? (
                    <div className="flex items-center gap-2">
                      <MessageGenerationStage className="px-0 py-0" />
                      <button
                        type="button"
                        onClick={onOpenThread}
                        className="text-xs text-primary hover:text-primary/80 underline transition-colors"
                      >
                        View in thread
                      </button>
                    </div>
                  ) : (
                    <p className="text-xs text-muted-foreground">
                      Cmd/Ctrl + Enter to send
                    </p>
                  )}
                  <div className="flex items-center">
                    <button
                      type="button"
                      onClick={handleMainAction}
                      disabled={!prompt.trim() || isPending}
                      className={cn(
                        "h-9 px-3 text-sm font-medium",
                        "bg-primary text-primary-foreground",
                        "hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed",
                        "transition-colors flex items-center gap-1",
                        "rounded-l-md border-r border-primary-foreground/20",
                      )}
                    >
                      {isPending && <>Sending...</>}
                      {!isPending &&
                        (sendMode === "thread" ? "Send in Thread" : "Send")}
                    </button>
                    <div className="relative inline-block">
                      <button
                        type="button"
                        onClick={(e) => {
                          e.stopPropagation();
                          const menu = e.currentTarget
                            .nextElementSibling as HTMLElement;
                          if (menu) {
                            menu.classList.toggle("hidden");
                          }
                        }}
                        disabled={!prompt.trim() || isPending}
                        className={cn(
                          "h-9 px-2 text-sm font-medium",
                          "bg-primary text-primary-foreground",
                          "hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed",
                          "transition-colors rounded-r-md",
                          "flex items-center justify-center",
                        )}
                      >
                        <ChevronDown className="h-3 w-3" />
                      </button>
                      <div
                        className="hidden absolute right-0 mt-2 w-40 rounded-md shadow-lg bg-popover text-popover-foreground border border-border z-50 p-1 animate-in fade-in-0 zoom-in-95 duration-100"
                        onClick={(e) => e.stopPropagation()}
                      >
                        <button
                          type="button"
                          onClick={(e) => {
                            e.stopPropagation();
                            const menu = e.currentTarget.parentElement;
                            if (menu) {
                              menu.classList.add("hidden");
                            }
                            setSendMode("send");
                          }}
                          className={cn(
                            "w-full px-2 py-1.5 text-left text-sm rounded-sm",
                            "hover:bg-accent hover:text-accent-foreground transition-colors cursor-pointer",
                            "focus:bg-accent focus:text-accent-foreground outline-none",
                            sendMode === "send" &&
                              "bg-accent text-accent-foreground",
                          )}
                        >
                          Send
                        </button>
                        <button
                          type="button"
                          onClick={(e) => {
                            e.stopPropagation();
                            const menu = e.currentTarget.parentElement;
                            if (menu) {
                              menu.classList.add("hidden");
                            }
                            setSendMode("thread");
                          }}
                          className={cn(
                            "w-full px-2 py-1.5 text-left text-sm rounded-sm",
                            "hover:bg-accent hover:text-accent-foreground transition-colors cursor-pointer",
                            "focus:bg-accent focus:text-accent-foreground outline-none",
                            sendMode === "thread" &&
                              "bg-accent text-accent-foreground",
                          )}
                        >
                          Send in Thread
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Error display */}
              {error && (
                <div className="p-2 rounded-md bg-destructive/10 text-destructive text-sm flex items-start gap-2">
                  <XCircle className="h-4 w-4 mt-0.5 shrink-0" />
                  <span>{error.message}</span>
                </div>
              )}
            </div>
          </div>,
          document.body,
        )}
    </>
  );
}
